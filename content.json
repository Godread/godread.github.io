{"pages":[],"posts":[{"title":"canvas钟表","text":"canvas可以绘制很多图形，这个实例绘制的是一个对准当前时间的钟表。其组成是：外层空心圆盘、时针刻度、时针、分针、秒针、表座、秒头。绘制时注意清除每次叠加的图形。 css部分12345678910111213141516171819* { margin: 0; padding: 0;}html,body { height: 100%; overflow: hidden; background: pink;}#clock { background: gray; position: absolute; top: 50%; left: 50%; transform: translate3d(-50%, -50%, 0);} html部分1234&lt;h2 align=&quot;center&quot; style=&quot;margin-top: 100px; color: blue;&quot;&gt;canvas-时针&lt;/h2&gt;&lt;canvas id=&quot;clock&quot; width=&quot;400&quot; height=&quot;400&quot;&gt; &lt;span&gt;你的浏览器不支持 canvas 元素,请升级当前浏览器或使用其他主流浏览器&lt;/span&gt;&lt;/canvas&gt; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111window.onload = function() { var clock = document.getElementById('clock'); if (clock.getContext) { var ctx = clock.getContext('2d'); setInterval(() =&gt; { // 清除每次叠加的图形 ctx.clearRect(0, 0, clock.width, clock.height); clockMove(); }, 1000); clockMove(); function clockMove() { // 初始化 ctx.save(); ctx.lineWidth = 8; ctx.strokeStyle = 'black'; ctx.lineCap = 'round'; ctx.translate(200, 200); ctx.rotate(-90 * Math.PI / 180); ctx.beginPath(); // 外层空心圆盘 ctx.save(); ctx.strokeStyle = '#325fa2'; ctx.lineWidth = 14; ctx.beginPath(); ctx.arc(0, 0, 140, 0, 360 * Math.PI / 180); ctx.stroke(); ctx.restore(); // 时针刻度 ctx.save(); for (var i = 0; i &lt; 12; i++) { ctx.beginPath(); ctx.moveTo(100, 0); ctx.lineTo(120, 0); ctx.rotate(30 * Math.PI / 180); ctx.stroke(); } ctx.restore(); // 分针刻度 ctx.save(); ctx.lineWidth = 4; for (var i = 0; i &lt; 60; i++) { if (i % 5 != 0) { ctx.beginPath(); ctx.moveTo(117, 0); ctx.lineTo(120, 0); ctx.stroke(); } ctx.rotate(6 * Math.PI / 180); } ctx.restore(); // 时针、分针、秒针、表座、秒头 var date = new Date(); var s = date.getSeconds(); var m = date.getMinutes(); var h = date.getHours(); h = h &gt; 12 ? h - 12 : h; // 时针 ctx.save(); ctx.lineWidth = 14; ctx.rotate(h * 30 * Math.PI / 180); ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(80, 0); ctx.stroke(); ctx.restore(); // 分针 ctx.save(); ctx.lineWidth = 10; ctx.rotate(m * 6 * Math.PI / 180); ctx.beginPath(); ctx.moveTo(-28, 0); ctx.lineTo(112, 0); ctx.stroke(); ctx.restore(); // 秒针 ctx.save(); ctx.lineWidth = 6; ctx.strokeStyle = '#d40000'; ctx.fillStyle = '#d40000'; ctx.rotate(s * 6 * Math.PI / 180); ctx.beginPath(); ctx.moveTo(-30, 0); ctx.lineTo(83, 0); ctx.stroke(); // 表座 ctx.beginPath(); ctx.arc(0, 0, 10, 0, 360 * Math.PI / 180); ctx.fill(); // 秒头 ctx.beginPath(); ctx.arc(96, 0, 10, 0, 360 * Math.PI / 180); ctx.stroke(); ctx.restore(); ctx.restore(); } }}","link":"/godread.github.io/canvas%E9%92%9F%E8%A1%A8.html"},{"title":"sublime配置less编译环境","text":"Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。Less 可以运行在 Node 或浏览器端。 一、确认是否已安装 node.js二、安装 npm 或 cnpm(此步可略过)如果 npm 安装失败，可使用 cnpm。命令行输入 1npm install -g cnpm --registry=https://registry.npm.taobao.org 等待安装完成。 三、全局安装 less(提示：如果npm安装失败，请尝试使用cnpm安装，方法与npm相同，将那npm替换为cnpm即可)命令行输入： 1npm install less -g 检查less环境是否配置完成，命令行输入： 1lessc -v 看是否能正确打印版本号。 四、继续安装命令行输入： 1npm install less-plugin-clean-css -g 五、在 sublime 安装插件 less2Css通过 package install 安装即可。 此时，创建的 less 文件在保存时可自动编译为相同名称的 css 文件。 另外有 koala app 可以直接编译 less 文件，而不必在 sublime 中安装插件去官网下载 koala app","link":"/godread.github.io/sublime%E9%85%8D%E7%BD%AEless%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83.html"},{"title":"zepto.js 简单的可无限增加内容的 h5 滑屏效果","text":"一个简单的 h5 页面，利用了 zepto.js 的一些 api，可以初步窥探 h5 效果的制作方式。其中尤其要注意的是滑动时的白页面问题，这与文档的结构有关，因此做了自动数量判断，用以解决对应序列页面的显隐。 页面在滑动时，会滑动到相应次序的页面，如下图所示 引入 css/js12345678*按文档结构安排路径*&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt; // 基础配置 css&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt; // 静态页面 css&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/animation.css&quot;&gt; // 动画 css&lt;script src=&quot;../node_modules/zepto/dist/zepto.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../node_modules/zepto/src/touch.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/index.js&quot;&gt;&lt;/script&gt; // 滑动逻辑 文档的结构是这样的：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;page-group pg-group1 page-current&quot; data-row=&quot;1&quot;&gt; &lt;div class=&quot;page page-1-1 page-current&quot;&gt; &lt;img class=&quot;img_1 pt-page-moveFromTop&quot; src=&quot;./images/page1_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 pt-page-moveFromLeft&quot; src=&quot;./images/page1_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;common_img pt-page-moveIconUp&quot; src=&quot;./images/page_up.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;page-group pg-group2 hide&quot; data-row=&quot;2&quot;&gt; &lt;div class=&quot;page page-2-1 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-moveFromBottom&quot; src=&quot;./images/page2-1_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-moveCircle&quot; src=&quot;./images/page2-1_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_3 hide pt-page-moveFromLeft&quot; src=&quot;./images/page2-1_3.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_4 hide pt-page-scaleUp&quot; src=&quot;./images/page2-1_4.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;common_img hide pt-page-moveIconUp&quot; src=&quot;./images/page_up.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;page page-2-2 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-flipInLeft&quot; src=&quot;./images/page2-2_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-flipInLeft&quot; src=&quot;./images/page2-2_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;common_img hide pt-page-moveIconUp&quot; src=&quot;./images/page_up.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;page-group pg-group3 hide&quot; data-row=&quot;2&quot;&gt; &lt;div class=&quot;page page-3-1 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-moveFromTop&quot; src=&quot;./images/page3-1_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-moveCircle&quot; src=&quot;./images/page3-1_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_3 hide pt-page-moveFromRight&quot; src=&quot;./images/page3-1_3.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_4 hide pt-page-scaleUp&quot; src=&quot;./images/page2-1_4.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;page page-3-2 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-moveFromBottom&quot; src=&quot;./images/page3-2_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-moveCircle&quot; src=&quot;./images/page3-2_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_3 hide pt-page-moveToLeft&quot; src=&quot;./images/page3-2_3.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; ......可以增加更多内页面组&lt;/div&gt; 公共图标就是底部的箭头图标，这些都可以自定义去留。 初始化数据1、滑动方向h5 页面的滑动不外乎四个方向，因此，在初始化数据时，定义一个变量，表示四个滑动方向 1let direction = {up: 1, right: 2, down: 3, left: 4}; 2、横纵方向的两个坐标还要初始化两个坐标，分别表示纵向滑动的页面和横向滑动的页面 12let last = {col: 0, row: 0}; // 表示出场页面let now = {col: 1, row: 1}; // 表示入场页面 3、判断页面是否在滑动状态另外需注意的是，在滑动时，如果操作过快，会导致入场页面还没有稳定展示就迅速出场，为了防止这种情况，需要在滑动时判断当前页面是否在滑动的状态中 1let isMoving = false; // 默认为 false,即没有滑动 4、计算文档中共有几个层级的主页面即计算纵向有几个主页面，横向页面为纵向页面的子页面 1let mainPage = $(&quot;.page-group&quot;).length; 滑动事件也即四个方向上的滑动事件，向上、向下、向左、向右。 1、向上滑动向上滑动时，计算滑动时出场、入场页面的坐标，并判断是否有相应坐标的入场页面存在，如果存在就入场，如果不存在就保持当前页面不动。 需注意：要先判断入场主页面的子页数量，以进入相应的页面。比如，page-2-2 上滑进入 page-3-2，一一对应。 123456789101112131415161718192021222324252627$(&quot;.page&quot;).on(&quot;swipeUp&quot;, function () { // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; if (last.col &lt; mainPage) { // 判断要出场的页面是否存在 // 获取要出场的页面的最大序号 let nowRow = $(this).parent('.page-group').next().attr('data-row'); // 当要出场页面的最大序号小于当前页面,即说明该出场页面不存在,禁止滑动 if (nowRow &lt; last.row) { return; } // 计算滑动之后进场页面的坐标 now.col = last.col + 1; now.row = last.row; movePage(direction.up); }}) 2、向下滑动逻辑与向下滑动类似 1234567891011121314151617181920212223242526272829// 向下滑动$(&quot;.page&quot;).on(&quot;swipeDown&quot;, function () { let _this = $(this); // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; if (last.col &gt; 1) { // 判断要出场的页面是否存在 // 获取要出场的页面的最大序号 let lastRow = $(this).parent('.page-group').prev().attr('data-row'); // 当要出场页面的最大序号小于当前页面,即说明该出场页面不存在,禁止滑动 if (lastRow &lt; now.row) { return; } // 计算滑动之后进场页面的坐标 now.col = last.col - 1; now.row = last.row; movePage(direction.down); }}); 3、向左滑动向左右滑动时，要注意是否会出现空白页，因此需要获取当前主页面的子页数量。由于出场页面是从 0 开始算的，但页面和 css 的命名都是从 1 开始的，因此滑动坐标需 &gt;1，同时 &lt;= mainPage(当前组的页面数量)。 12345678910111213141516171819202122232425// 向左滑动$(&quot;.page&quot;).on(&quot;swipeLeft&quot;, function () { // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; // 获取当前页面组的数量 let maxPage = $(this).parent(&quot;.page-group&quot;).attr(&quot;data-row&quot;); if (last.col &gt; 1 &amp;&amp; last.col &lt;= mainPage) { // 如果要出场的页面序号小于当前的页面数量,即滑动,否则不动 if (last.row &lt; maxPage) { // 计算滑动之后进场页面的坐标 now.col = last.col; now.row = last.row + 1; movePage(direction.left); } }}); 4、向右滑动与向左类似 12345678910111213141516171819202122// 向右滑动$(&quot;.page&quot;).on(&quot;swipeRight&quot;, function () { // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; if (last.col &gt; 1 &amp;&amp; last.col &lt;= mainPage &amp;&amp; last.row &gt; 0) { // 如果当前页面序号大于1(使 now.row 不能等于1),则可以滑动,否则,不滑动 if (last.row &gt; 1) { // 计算滑动之后进场页面的坐标 now.col = last.col; now.row = last.row - 1; movePage(direction.right); } }}); 定义一个滑动函数四个方向的滑动都需要用到这个函数。 页面滑动时，出入场页面增加或移除相应的样式，匹配相应的方向，表示显隐状态。 页面中的每一个图片都要在初始状态隐藏(.hide {display: none;})，这样就不会在页面没有显示时就完成了过渡效果。 在滑动完成后，出场页面图片会停留在当前页面，因此需要在动画执行完成后进行清除，即隐藏。 要注意动画执行完成后，调整页面滑动状态 isMoving。 实际上就是根据方向匹配相应的 css 过渡动画，执行显隐状态的切换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 定义一个滑动的功能函数function movePage(dir) { // 初始化参与动画的页面 let lastPage = &quot;.page-&quot; + last.col + &quot;-&quot; + last.row; let nowPage = &quot;.page-&quot; + now.col + &quot;-&quot; + now.row; // 初始两个动画类 let inClass = &quot;&quot; // 进场动画类 let outClass = &quot;&quot; // 出场动画类 // 匹配方向 switch (dir) { case direction.up: outClass = &quot;pt-page-moveToTop&quot;; inClass = &quot;pt-page-moveFromBottom&quot;; break; case direction.right: outClass = &quot;pt-page-moveToRight&quot;; inClass = &quot;pt-page-moveFromLeft&quot;; break; case direction.bottom: outClass = &quot;pt-page-moveToBottom&quot;; inClass = &quot;pt-page-moveFromTop&quot;; break; case direction.left: outClass = &quot;pt-page-moveToLeft&quot;; inClass = &quot;pt-page-moveFromRight&quot;; break; } // 将动画类加到参与动画的页面上 $(lastPage).addClass(outClass).addClass(&quot;hide&quot;); $(nowPage).removeClass(&quot;hide&quot;).addClass(inClass); // 滑动时设置当前滑动状态为 true isMoving = true; // 动画执行完清除动画类 setTimeout(function () { $(lastPage).find(&quot;img&quot;).addClass(&quot;hide&quot;); $(lastPage).removeClass(outClass).removeClass(&quot;page-current&quot;).addClass(&quot;hide&quot;); $(lastPage).parent('.page-group').removeClass('page-current').addClass('hide'); $(nowPage).parent('.page-group').removeClass('hide').addClass('page-current'); $(nowPage).find(&quot;img&quot;).removeClass(&quot;hide&quot;); $(nowPage).removeClass(&quot;hide&quot;).addClass(&quot;page-current&quot;).removeClass(inClass); // 动画执行完停止滑动状态 isMoving = false; }, 600);} 最后要注意的是，禁止页面的默认触摸事件，在 css 中的 .page 里设置 touch-action: none 即可。 完整的项目：zeptojs-h5","link":"/godread.github.io/zeptojs%E7%AE%80%E5%8D%95H5%E9%A1%B5%E9%9D%A2%E6%BB%91%E5%B1%8F%E6%95%88%E6%9E%9C.html"},{"title":"栅格盒模型设计的精妙之处","text":"容器两边具有 15px 的 padding，行两边具有 -15px 的 margin，列两边具有 15px 的 padding。 它的精妙之处在于三点： 1、为了维护槽宽的规则 ​ 列两边必须得要 15px 的 padding 2、为了能使列嵌套行 ​ 行两边必须要有 -15px 的 padding 3、为了让容器可以包裹行 ​ 容器两边必须要有 15px 的 padding 这样才可以使得容器在行和列的嵌套下遵循设定的规则。","link":"/godread.github.io/%E6%A0%85%E6%A0%BC%E7%9B%92%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%B2%BE%E5%A6%99%E4%B9%8B%E5%A4%84.html"},{"title":"解决跨域问题的几个主要方案","text":"跨域就是跨资源请求，域名由协议、子域名、主域名、端口号组成，当其中任意一个不相同时，都算作不同域，不同域之间相互请求资源，即“跨域”。不过，跨域的请求可以正常发送，服务端也可以正常收到请求并返回结果，只是被浏览器拦截了。 跨域简介之所在存在跨域，是受到了同源策略的的限制，同源策略要求源相同才能正常通信，以维护资源安全，即要求协议、域名、端口号完全一致。 同源策略，就是为了隔离潜在的恶意文件对资源的侵害，它建造了一种保护用户隐私，防止读取 cookie 进行身份伪造等的安全机制。 同源策略的限制内容有： Cookie、LocalStorage、IndexedDB等存储性内容 DOM 节点 AJAX 请求不能发送 同时有三个标签允许跨资源请求： 123&lt;img src=&quot;xxx&quot;&gt;&lt;link href=&quot;xxx&quot;&gt;&lt;script src=&quot;xxx&quot;&gt; 跨域的解决方案1、jsonp 原理：jsonp 利用了&lt;script&gt; 标签的开放策略，可以获得 json 数据，但请求必须获得服务器支持。 优缺点： 优点是兼容性好，可以解决主流浏览器的跨域访问问题。 缺点是仅支持 get 方法，有局限性。 jsonp 的解决方案： 在客户端声明一个函数 fn，将该函数名作为参数值以 url_encode 方式传递给服务器，该函数形参作为服务器返回的数据。 创建 &lt;script&gt; 标签，直接请求数据接口地址，将定义好的函数 fn 作为参数值传递给服务器（&amp;callback=fn）。 服务器接收请求后，把客户端传递进来的 fn 与数据拼成字符串，返回给客户端。 客户端收到返回的数据后，直接进行操作。 12345// 客户端：&lt;script src=&quot;http://abc.com/jsonData?jsonp=fn&quot;&gt;&lt;/script&gt;// 服务器：返回fn([{&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 20}]) jQuery 中的 jsonp 是直接用 $.ajax() 解决的，不赘述。 2、CORS如果说 jsonp 是一种技巧的话，那 CORS 就是一种技术。 整个通信过程，不需要用户参与，浏览器自动完成。实际上，它与 ajax 同源通信没有区别，关键是服务器设置允许跨域即可。 CORS 对 IE10 以上才可以支持，兼容性不如 jsonp，但功能强大，支持各种 HTTP Method。 解决方案：服务器端设置即可 1header(&quot;Access-Control-Allow-Origin:*&quot;); header(&quot;Access-Control-Allow-Methods:POST,GET&quot;); 在响应头上添加 Access-Control-Allow-Origin 属性，指定同源策略的地址，默认是网页本身。浏览器检测到响应头上带有 CORS，并且允许的源包含本网站，就不会拦截请求响应。 3、WebSocketWebSocket和HTTP都是应用层协议，都基于 TCP 协议。但 WebSocket 是一种双向通信协议，在建立连接时需要借助 HTTP 协议，连接建立之后 WebSocket 的 client 和 server 就可以主动发送和接收数据了，通信时与 HTTP 无关。 Socket.io 中封装了 WebSocket 接口，增强了兼容性。 123456789101112131415161718192021222324//前端代码： &lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://www.abc.com:8080'); // 连接成功处理 socket.on('connect', function() { // 监听服务端消息 socket.on('message', function(msg) { console.log('data from server: ---&gt; ' + msg); }); // 监听服务端关闭 socket.on('disconnect', function() { console.log('Server socket has closed.'); }); }); document.getElementsByTagName('input')[0].onblur = function() { socket.send(this.value); };&lt;/script&gt; 1234567891011121314151617181920212223242526//Nodejs socket后台：var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) { res.writeHead(200, {'Content-type': 'text/html'}); res.end();});server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) { // 接收信息 client.on('message', function(msg) { client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); }); // 断开处理 client.on('disconnect', function() { console.log('Client socket has closed.'); });}); 4、postMessage使用该方法最典型的就是不同源的 iframe 窗口和 window.open 打开的窗口了，它们与父窗口无法通信。因此，HTML5 引入了一个新的 API，叫跨文档通信 API（Cross-document messaging）。这个 API 为 window 对象新增了一个 postMessage 方法，允许非同源跨窗口通信。 postMessage(data, url); // data 是具体的信息数据, url 是一个完整的接收消息的窗口的源,它可以设置为 *，表示不限制域名，向所有窜发送。 比如，某个页面向另一个页面传递跨域信息： 123456789101112131415161718//发送信息的页面 http://localhost:63342/index.html&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;跨域请求&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://localhost:3000/users/reg&quot; id=&quot;frm&quot;&gt;&lt;/iframe&gt; &lt;input type=&quot;button&quot; value=&quot;OK&quot; onclick=&quot;run()&quot;&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; function run(){ var frm=document.getElementById(&quot;frm&quot;); frm.contentWindow.postMessage(&quot;跨域请求信息&quot;,&quot;http://localhost:3000&quot;); }&lt;/script&gt; 12345//接收信息的页面 http://localhost:3000/message.htmlwindow.addEventListener(&quot;message&quot;,function(e){ //通过监听message事件，可以监听对方发送的消息。 console.log(e.data);},false); 5、降域降域只适用于同一个主域名下的不同源之间的请求。 原理：将两个域名都降域，就可以互相请求资源。即通过 js 强制设置 document.domain = 主域名。 例如：a.abc.com/a.html 获取 b.abc.com/b.html 中的 a 值。 123456789101112// a.html&lt;body&gt;&lt;iframe src=&quot;b.abc.com/b.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;frame&quot;&gt;&lt;script&gt; document.domain = &quot;abc.com&quot;; // 降域 function load() { console.log(frame.contentWindow.a); }&lt;/script&gt;&lt;/doby&gt; 1234567// b.html&lt;body&gt;&lt;script&gt; document.domain = &quot;abc.com&quot;; // 降域 let a = 100;&lt;/script&gt;&lt;/body&gt; 6、iframe 与 window.namewindow.name 可以在不同页面加载后一直存在，并且长度值最大为 2M，可以借助这个特性绕过同源策略的限制。 例如，a.html 和 b.html 同源，c.html 不同源，想请求 c 页面的数据，可以以 b 页面为中间代理页，在 a 页面中使用 iframe 跨域请求 c.html。 假如 a.html 和 b.html 同源为 localhost:3000，c 为 localhost:4000 123456789101112131415161718// a.html(http://localhost:3000/a.html)&lt;iframe src=&quot;http://localhost:4000/c.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;iframe&quot;&gt;&lt;/iframe&gt;&lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() { if(first){ // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; }else{ // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); }}&lt;/script&gt; 1234// c.html(http://localhost:4000/c.html)&lt;script&gt; window.name = '我不爱你' &lt;/script&gt; 利用 iframe 的 src 属性由跨域转向同域，跨域数据因 window.name 的特性得以保留并传递到本域。 由于 iframe 有兼容性问题，故此方法用得不多。","link":"/godread.github.io/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E6%96%B9%E6%A1%88.html"}],"tags":[{"name":"canvas","slug":"canvas","link":"/godread.github.io/tags/canvas/"},{"name":"cases","slug":"cases","link":"/godread.github.io/tags/cases/"},{"name":"sublime text3","slug":"sublime-text3","link":"/godread.github.io/tags/sublime-text3/"},{"name":"less","slug":"less","link":"/godread.github.io/tags/less/"},{"name":"h5","slug":"h5","link":"/godread.github.io/tags/h5/"},{"name":"zepto.js","slug":"zepto-js","link":"/godread.github.io/tags/zepto-js/"},{"name":"bootstrap","slug":"bootstrap","link":"/godread.github.io/tags/bootstrap/"},{"name":"跨域","slug":"跨域","link":"/godread.github.io/tags/%E8%B7%A8%E5%9F%9F/"}],"categories":[{"name":"html5&amp;css3","slug":"html5-css3","link":"/godread.github.io/categories/html5-css3/"},{"name":"工具","slug":"工具","link":"/godread.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"javascript","slug":"javascript","link":"/godread.github.io/categories/javascript/"}]}