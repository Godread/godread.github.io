{"pages":[],"posts":[{"title":"sublime配置less编译环境","text":"Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。Less 可以运行在 Node 或浏览器端。 一、确认是否已安装 node.js二、安装 npm 或 cnpm(此步可略过)如果 npm 安装失败，可使用 cnpm。命令行输入 1npm install -g cnpm --registry=https://registry.npm.taobao.org 等待安装完成。 三、全局安装 less(提示：如果npm安装失败，请尝试使用cnpm安装，方法与npm相同，将那npm替换为cnpm即可)命令行输入： 1npm install less -g 检查less环境是否配置完成，命令行输入： 1lessc -v 看是否能正确打印版本号。 四、继续安装命令行输入： 1npm install less-plugin-clean-css -g 五、在 sublime 安装插件 less2Css通过 package install 安装即可。 此时，创建的 less 文件在保存时可自动编译为相同名称的 css 文件。 另外有 koala app 可以直接编译 less 文件，而不必在 sublime 中安装插件去官网下载 koala app","link":"/725c7ed5.html"},{"title":"canvas钟表","text":"canvas可以绘制很多图形，这个实例绘制的是一个对准当前时间的钟表。其组成是：外层空心圆盘、时针刻度、时针、分针、秒针、表座、秒头。绘制时注意清除每次叠加的图形。 css部分12345678910111213141516171819* { margin: 0; padding: 0;}html,body { height: 100%; overflow: hidden; background: pink;}#clock { background: gray; position: absolute; top: 50%; left: 50%; transform: translate3d(-50%, -50%, 0);} html部分1234&lt;h2 align=&quot;center&quot; style=&quot;margin-top: 100px; color: blue;&quot;&gt;canvas-时针&lt;/h2&gt;&lt;canvas id=&quot;clock&quot; width=&quot;400&quot; height=&quot;400&quot;&gt; &lt;span&gt;你的浏览器不支持 canvas 元素,请升级当前浏览器或使用其他主流浏览器&lt;/span&gt;&lt;/canvas&gt; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111window.onload = function() { var clock = document.getElementById('clock'); if (clock.getContext) { var ctx = clock.getContext('2d'); setInterval(() =&gt; { // 清除每次叠加的图形 ctx.clearRect(0, 0, clock.width, clock.height); clockMove(); }, 1000); clockMove(); function clockMove() { // 初始化 ctx.save(); ctx.lineWidth = 8; ctx.strokeStyle = 'black'; ctx.lineCap = 'round'; ctx.translate(200, 200); ctx.rotate(-90 * Math.PI / 180); ctx.beginPath(); // 外层空心圆盘 ctx.save(); ctx.strokeStyle = '#325fa2'; ctx.lineWidth = 14; ctx.beginPath(); ctx.arc(0, 0, 140, 0, 360 * Math.PI / 180); ctx.stroke(); ctx.restore(); // 时针刻度 ctx.save(); for (var i = 0; i &lt; 12; i++) { ctx.beginPath(); ctx.moveTo(100, 0); ctx.lineTo(120, 0); ctx.rotate(30 * Math.PI / 180); ctx.stroke(); } ctx.restore(); // 分针刻度 ctx.save(); ctx.lineWidth = 4; for (var i = 0; i &lt; 60; i++) { if (i % 5 != 0) { ctx.beginPath(); ctx.moveTo(117, 0); ctx.lineTo(120, 0); ctx.stroke(); } ctx.rotate(6 * Math.PI / 180); } ctx.restore(); // 时针、分针、秒针、表座、秒头 var date = new Date(); var s = date.getSeconds(); var m = date.getMinutes(); var h = date.getHours(); h = h &gt; 12 ? h - 12 : h; // 时针 ctx.save(); ctx.lineWidth = 14; ctx.rotate(h * 30 * Math.PI / 180); ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(80, 0); ctx.stroke(); ctx.restore(); // 分针 ctx.save(); ctx.lineWidth = 10; ctx.rotate(m * 6 * Math.PI / 180); ctx.beginPath(); ctx.moveTo(-28, 0); ctx.lineTo(112, 0); ctx.stroke(); ctx.restore(); // 秒针 ctx.save(); ctx.lineWidth = 6; ctx.strokeStyle = '#d40000'; ctx.fillStyle = '#d40000'; ctx.rotate(s * 6 * Math.PI / 180); ctx.beginPath(); ctx.moveTo(-30, 0); ctx.lineTo(83, 0); ctx.stroke(); // 表座 ctx.beginPath(); ctx.arc(0, 0, 10, 0, 360 * Math.PI / 180); ctx.fill(); // 秒头 ctx.beginPath(); ctx.arc(96, 0, 10, 0, 360 * Math.PI / 180); ctx.stroke(); ctx.restore(); ctx.restore(); } }}","link":"/8f5b3dc2.html"},{"title":"测试文章","text":"测试文章是否可用SSH配置上传 是的，配置完成后查看效果。","link":"/7a6a6b5a.html"},{"title":"zepto.js 简单的可无限增加内容的 h5 滑屏效果","text":"一个简单的 h5 页面，利用了 zepto.js 的一些 api，可以初步窥探 h5 效果的制作方式。其中尤其要注意的是滑动时的白页面问题，这与文档的结构有关，因此做了自动数量判断，用以解决对应序列页面的显隐。 页面在滑动时，会滑动到相应次序的页面，如下图所示 引入 css/js12345678*按文档结构安排路径*&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt; // 基础配置 css&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt; // 静态页面 css&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/animation.css&quot;&gt; // 动画 css&lt;script src=&quot;../node_modules/zepto/dist/zepto.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../node_modules/zepto/src/touch.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/index.js&quot;&gt;&lt;/script&gt; // 滑动逻辑 文档的结构是这样的：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;page-group pg-group1 page-current&quot; data-row=&quot;1&quot;&gt; &lt;div class=&quot;page page-1-1 page-current&quot;&gt; &lt;img class=&quot;img_1 pt-page-moveFromTop&quot; src=&quot;./images/page1_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 pt-page-moveFromLeft&quot; src=&quot;./images/page1_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;common_img pt-page-moveIconUp&quot; src=&quot;./images/page_up.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;page-group pg-group2 hide&quot; data-row=&quot;2&quot;&gt; &lt;div class=&quot;page page-2-1 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-moveFromBottom&quot; src=&quot;./images/page2-1_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-moveCircle&quot; src=&quot;./images/page2-1_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_3 hide pt-page-moveFromLeft&quot; src=&quot;./images/page2-1_3.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_4 hide pt-page-scaleUp&quot; src=&quot;./images/page2-1_4.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;common_img hide pt-page-moveIconUp&quot; src=&quot;./images/page_up.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;page page-2-2 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-flipInLeft&quot; src=&quot;./images/page2-2_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-flipInLeft&quot; src=&quot;./images/page2-2_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;common_img hide pt-page-moveIconUp&quot; src=&quot;./images/page_up.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;page-group pg-group3 hide&quot; data-row=&quot;2&quot;&gt; &lt;div class=&quot;page page-3-1 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-moveFromTop&quot; src=&quot;./images/page3-1_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-moveCircle&quot; src=&quot;./images/page3-1_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_3 hide pt-page-moveFromRight&quot; src=&quot;./images/page3-1_3.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_4 hide pt-page-scaleUp&quot; src=&quot;./images/page2-1_4.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;page page-3-2 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-moveFromBottom&quot; src=&quot;./images/page3-2_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-moveCircle&quot; src=&quot;./images/page3-2_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_3 hide pt-page-moveToLeft&quot; src=&quot;./images/page3-2_3.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; ......可以增加更多内页面组&lt;/div&gt; 公共图标就是底部的箭头图标，这些都可以自定义去留。 初始化数据1、滑动方向h5 页面的滑动不外乎四个方向，因此，在初始化数据时，定义一个变量，表示四个滑动方向 1let direction = {up: 1, right: 2, down: 3, left: 4}; 2、横纵方向的两个坐标还要初始化两个坐标，分别表示纵向滑动的页面和横向滑动的页面 12let last = {col: 0, row: 0}; // 表示出场页面let now = {col: 1, row: 1}; // 表示入场页面 3、判断页面是否在滑动状态另外需注意的是，在滑动时，如果操作过快，会导致入场页面还没有稳定展示就迅速出场，为了防止这种情况，需要在滑动时判断当前页面是否在滑动的状态中 1let isMoving = false; // 默认为 false,即没有滑动 4、计算文档中共有几个层级的主页面即计算纵向有几个主页面，横向页面为纵向页面的子页面 1let mainPage = $(&quot;.page-group&quot;).length; 滑动事件也即四个方向上的滑动事件，向上、向下、向左、向右。 1、向上滑动向上滑动时，计算滑动时出场、入场页面的坐标，并判断是否有相应坐标的入场页面存在，如果存在就入场，如果不存在就保持当前页面不动。 需注意：要先判断入场主页面的子页数量，以进入相应的页面。比如，page-2-2 上滑进入 page-3-2，一一对应。 123456789101112131415161718192021222324252627$(&quot;.page&quot;).on(&quot;swipeUp&quot;, function () { // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; if (last.col &lt; mainPage) { // 判断要出场的页面是否存在 // 获取要出场的页面的最大序号 let nowRow = $(this).parent('.page-group').next().attr('data-row'); // 当要出场页面的最大序号小于当前页面,即说明该出场页面不存在,禁止滑动 if (nowRow &lt; last.row) { return; } // 计算滑动之后进场页面的坐标 now.col = last.col + 1; now.row = last.row; movePage(direction.up); }}) 2、向下滑动逻辑与向下滑动类似 1234567891011121314151617181920212223242526272829// 向下滑动$(&quot;.page&quot;).on(&quot;swipeDown&quot;, function () { let _this = $(this); // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; if (last.col &gt; 1) { // 判断要出场的页面是否存在 // 获取要出场的页面的最大序号 let lastRow = $(this).parent('.page-group').prev().attr('data-row'); // 当要出场页面的最大序号小于当前页面,即说明该出场页面不存在,禁止滑动 if (lastRow &lt; now.row) { return; } // 计算滑动之后进场页面的坐标 now.col = last.col - 1; now.row = last.row; movePage(direction.down); }}); 3、向左滑动向左右滑动时，要注意是否会出现空白页，因此需要获取当前主页面的子页数量。由于出场页面是从 0 开始算的，但页面和 css 的命名都是从 1 开始的，因此滑动坐标需 &gt;1，同时 &lt;= mainPage(当前组的页面数量)。 12345678910111213141516171819202122232425// 向左滑动$(&quot;.page&quot;).on(&quot;swipeLeft&quot;, function () { // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; // 获取当前页面组的数量 let maxPage = $(this).parent(&quot;.page-group&quot;).attr(&quot;data-row&quot;); if (last.col &gt; 1 &amp;&amp; last.col &lt;= mainPage) { // 如果要出场的页面序号小于当前的页面数量,即滑动,否则不动 if (last.row &lt; maxPage) { // 计算滑动之后进场页面的坐标 now.col = last.col; now.row = last.row + 1; movePage(direction.left); } }}); 4、向右滑动与向左类似 12345678910111213141516171819202122// 向右滑动$(&quot;.page&quot;).on(&quot;swipeRight&quot;, function () { // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; if (last.col &gt; 1 &amp;&amp; last.col &lt;= mainPage &amp;&amp; last.row &gt; 0) { // 如果当前页面序号大于1(使 now.row 不能等于1),则可以滑动,否则,不滑动 if (last.row &gt; 1) { // 计算滑动之后进场页面的坐标 now.col = last.col; now.row = last.row - 1; movePage(direction.right); } }}); 定义一个滑动函数四个方向的滑动都需要用到这个函数。 页面滑动时，出入场页面增加或移除相应的样式，匹配相应的方向，表示显隐状态。 页面中的每一个图片都要在初始状态隐藏(.hide {display: none;})，这样就不会在页面没有显示时就完成了过渡效果。 在滑动完成后，出场页面图片会停留在当前页面，因此需要在动画执行完成后进行清除，即隐藏。 要注意动画执行完成后，调整页面滑动状态 isMoving。 实际上就是根据方向匹配相应的 css 过渡动画，执行显隐状态的切换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 定义一个滑动的功能函数function movePage(dir) { // 初始化参与动画的页面 let lastPage = &quot;.page-&quot; + last.col + &quot;-&quot; + last.row; let nowPage = &quot;.page-&quot; + now.col + &quot;-&quot; + now.row; // 初始两个动画类 let inClass = &quot;&quot; // 进场动画类 let outClass = &quot;&quot; // 出场动画类 // 匹配方向 switch (dir) { case direction.up: outClass = &quot;pt-page-moveToTop&quot;; inClass = &quot;pt-page-moveFromBottom&quot;; break; case direction.right: outClass = &quot;pt-page-moveToRight&quot;; inClass = &quot;pt-page-moveFromLeft&quot;; break; case direction.bottom: outClass = &quot;pt-page-moveToBottom&quot;; inClass = &quot;pt-page-moveFromTop&quot;; break; case direction.left: outClass = &quot;pt-page-moveToLeft&quot;; inClass = &quot;pt-page-moveFromRight&quot;; break; } // 将动画类加到参与动画的页面上 $(lastPage).addClass(outClass).addClass(&quot;hide&quot;); $(nowPage).removeClass(&quot;hide&quot;).addClass(inClass); // 滑动时设置当前滑动状态为 true isMoving = true; // 动画执行完清除动画类 setTimeout(function () { $(lastPage).find(&quot;img&quot;).addClass(&quot;hide&quot;); $(lastPage).removeClass(outClass).removeClass(&quot;page-current&quot;).addClass(&quot;hide&quot;); $(lastPage).parent('.page-group').removeClass('page-current').addClass('hide'); $(nowPage).parent('.page-group').removeClass('hide').addClass('page-current'); $(nowPage).find(&quot;img&quot;).removeClass(&quot;hide&quot;); $(nowPage).removeClass(&quot;hide&quot;).addClass(&quot;page-current&quot;).removeClass(inClass); // 动画执行完停止滑动状态 isMoving = false; }, 600);} 最后要注意的是，禁止页面的默认触摸事件，在 css 中的 .page 里设置 touch-action: none 即可。 完整的项目：zeptojs-h5","link":"/da582b16.html"},{"title":"实现简单的axios异步增删改查功能","text":"手动实现一个简单的 axios 增删改查的功能封装，实现非 rest API 接口的数据请求，数据的模拟用 json-server 来实现 预备数据首先，全局安装 json-server 1npm install -g json-server 在本地建立 db.json 文，并填充数据 12345678910111213{ &quot;posts&quot;: [ {&quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot;}, {&quot;id&quot;: 2, &quot;title&quot;: &quot;json-server2&quot;, &quot;author&quot;: &quot;typicode2&quot;}, {&quot;title&quot;: &quot;json-server+++&quot;, &quot;author&quot;: &quot;typicode+++&quot;, &quot;id&quot;: 3} ], &quot;comments&quot;: [ {&quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1} ], &quot;profile&quot;: { &quot;name&quot;: &quot;typicode&quot; }} 实现原理html代码123456&lt;div&gt; &lt;button onclick=&quot;testGet()&quot;&gt;xhr发送GET请求&lt;/button&gt; &lt;button onclick=&quot;testPost()&quot;&gt;xhr发送请POST求&lt;/button&gt; &lt;button onclick=&quot;testPut()&quot;&gt;xhr发送PUT请求&lt;/button&gt; &lt;button onclick=&quot;testDelete()&quot;&gt;xhr发送DELETE请求&lt;/button&gt;&lt;/div&gt; js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// 引入 xios&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.20.0/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 调用axios function testGet() { axios({ url: 'http://localhost:3000/posts', method: &quot;get&quot;, params: { 'id': 2, &quot;title&quot;: 'json-server2' } }).then( response =&gt; { console.log(response) }, error =&gt; { alert(error.message) } ) } function testPost() { axios({ url: 'http://localhost:3000/posts', method: &quot;post&quot;, data: { &quot;title&quot;: &quot;json-server---&quot;, &quot;author&quot;: &quot;typicode---&quot; } }).then( response =&gt; { console.log(response) }, error =&gt; { alert(error.message) } ) } function testPut() { axios({ url: 'http://localhost:3000/posts/3', method: &quot;put&quot;, data: { &quot;title&quot;: &quot;json-server+++&quot;, &quot;author&quot;: &quot;typicode+++&quot; } }).then( response =&gt; { console.log(response) }, error =&gt; { alert(error.message) } ) } function testDelete() { axios({ url: 'http://localhost:3000/posts/4', method: &quot;delete&quot;, }).then( response =&gt; { console.log(response) }, error =&gt; { alert(error.message) } ) } /** * 封装axios ---&gt; 原理 */ function axios({ url, method = 'GET', params = {}, data = {} }) { // 返回一个promise对象 return new Promise((resolve, reject) =&gt; { // 处理method，变为大写 method = method.toUpperCase() // 处理query参数(拼接到url上) id=1&amp;xxx=abc /* { id: 1, xxx: abc } */ let queryString = '' Object.keys(params).forEach((key) =&gt; { queryString += `${key}=${params[key]}&amp;` }) if (queryString) { // 去除最后面的&amp; queryString = queryString.substring(0, queryString.length - 1) // 拼接到url上 url += '?' + queryString } // 1.执行异步ajax请求 // 创建xhr对象 const request = new XMLHttpRequest() // 打开连接(初始化请求，没有请求) request.open(method, url, true) // 开启异步 // 发送请求 // 这里有method必须要大写，因为上面己经处理method为大写，保持一致 if (method === 'GET' || method === 'DELETE') { request.send() } else if (method === 'POST' || method === 'PUT') { // 发送json数据时，要设置请求头，告诉服务器，请求体的格式是json request.setRequestHeader('Content-Type', 'application/json;charset=utf-8') request.send(JSON.stringify(data)) // 发送json格式请求体参数 } // 2.绑定状态改变的监听 request.onreadystatechange = function() { // 如果请求没有完成，直接结束 if (request.readyState !== 4) { return } // 如果状态响应码在200-300之间，代表成功，否则失败 const { status, statusText } = request // 2.1.如果请求成功了，调用resolve() if (status &gt;= 200 &amp; status &lt;= 299) { // 准备结果数据对象response const response = { data: JSON.parse(request.response), status, statusText } resolve(response) } else { // 2.2. 如果请求失败了，调用reject() reject(new Error('request error status is ' + status)) } } }) }&lt;/script&gt;","link":"/6581d66.html"},{"title":"两个hexo博客的多端同步管理与推送问题","text":"在一个电脑上管理两个或多个hexo博客，在推送和多端同步时会再现一些问题，比如凭证覆盖、远程下载上传等 建立不同的 hexo 博客需要不同的 github 账号，创建过程较为简单，比较伤脑筋的首先是多端同步问题。 一、hexo博客的多端同步问题在使用 hexo 博客时，通常不会总是在同一台电脑上发文章，可能会在不同的地方有发文章的需求，拷贝既不快又不方便，因此需要源文件同步。 博客源文件同步写完文章部署到网站 1234hexo cleanhexo ghexo s // 本地查看效果，可略过hexo d // 将本地源文件推送到github仓库 再进行如下操作 123git add . // 所有变化提交到暂存区git commit -m &quot;新增xxx文章&quot; // 提交文件git push origin hexo // 推送hexo分支 这就将源文件上传到 github 了。 github 上建立一个分支 hexo，建议将其设置为默认分支，用来保存环境文件，master 用来保存文章相关内容。 在其他电脑上同步博客电脑上安装 node 和 git，然后下载 github 博客文章与环境文件，执行如下操作 1234npm install hexo-cli -g // 先安装 hexo 的脚手架git clone git@github.com:xxx/xxx.github.io.git // 下载项目，因为 hexo 是默认分支，所以这里直接会下载 hexo 分支npm i // 安装依赖hexo s // 启动服务器 此时己经完成了同步下载博客，之后在其他电脑上写完文章后，在博客根目录使用 hexo 推送文章，然后执行如下操作 123456git initgit remote add origin git@github.com:xxx/xxx.github.io.git // 加远程仓库,注意这里要添加你自己的仓库,xxx即用户名git checkout -b hexo // 新建 hexo 分支并切换到 hexo 分支git add . // 所有变化提交到暂存区git commit -m &quot;解决同步问题&quot; // 提交文件git push origin hexo // 推送到 hexo 分支 如果该电脑不止一次使用过，则只需从 git add . 开始即可。 这样就完成了多端同步，其核心即下载仓库、写文章、推送文章。 在下载仓库时，也可以使用 git pull，效果与 git clone 类似，都是下载项目。 提示：在建立 github 博客时，最好先创建 hexo 分支，在推送文章时，即按照以上步骤，将环境文件保存于 hexo 分支，将文章相关推送到 master 二、SSH公钥管理同一台电脑上管理两个 hexo 博客时，ssh 绑定 github 账号有时会出现问题，导致无法推送文章，其原理为： 1）SSH 的公钥是 GitHub 作为本地仓库和远程仓库连接的唯一标识，一个公钥只能对应一个 GitHub 账户，如果将一个相同的公钥上传到不同的 GitHub 账户，GitHub 则无法做出辨识，进而导致错误。 2）一台电脑，可以生成多对公私钥，可以通过配置，将不同的公钥上传到不同的 GitHub 账号，那么就不存在单个公钥绑定多个 GitHub 账号的情况存在了。 相关报错信息为： 1）同一台电脑部署第二个 hexo 博客执行hexo g -d时报错：ERROR: Permission to xxxxxx/xxxxxx.github.io.git denied to xxxxxx. 2）添加新的 SSH 密钥 到 SSH agent 执行ssh-add xxx时报错：Could not open a connection to your authentication agent. 3）单独设置用户名/邮箱时报错：fatal: not in a git directory 解决这些问题，需要操作 ssh 公钥。 如果没有创建公钥，则操作如下： 查看当前密钥1ls ~/.ssh/ // 打开终端，可以查看当前已存在的密钥。 创建新密钥进入 SSH 根目录 1cd ~/.ssh/ 创建密钥 方法一： 1ssh-keygen -t rsa -f ~/.ssh/新密钥名称 -C &quot;github账号邮箱&quot; // 注意密钥名称不能相同 按步骤设定密码。 方法二： 1ssh-keygen -t rsa -C &quot;github账号邮箱&quot; 回车后出现： 12Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): 注意此时需要输入新密钥的名称，注意区别新密钥名称和旧密钥名称，不要相同。之后再两次回车，新密钥创建完毕。 配置config在 .ssh/ 根目路下，查看是否存在 config 文件，如果没有就创建一个。（我的根目录为 C:\\Users\\Lenovo.ssh） 1touch config // 要么用这个命令创建，要么手动创建 在config文件中配置如下： 1234567891011// 第一个账号，默认使用的账号，不用做任何更改Host xxx.github.com HostName github.com User git IdentityFile ~/.ssh/新密钥的名称1 // 第二个新账号，&quot;xxx&quot;为前缀名，可以任意设置，需要用到Host xxx.github.com HostName github.com User git IdentityFile ~/.ssh/新密钥的名称2 复制创建的公钥内容： 1clip &lt; ~/.ssh/创建的新密钥的名称.pub 或者可以用记事本打开 xxx.pub 并复制内容，将其分别填入对应的 github 账户的 setting 的 SSH and GPG keys 的 New SSH key 中。 清空本地的 SSH 缓存，添加新的 SSH 密钥 到 SSH agent中在 .ssh/ 根目录下，依次执行： 123ssh-add -Dssh-add xxxxxx // 旧密钥名称，一般是 id_rsa，或之前的账号创建的ssh-add xxxxxx // 新创建的密钥名称 如果执行以上命令出现错误：Could not open a connection to your authentication agent.，那么就需要先执行ssh-agent bash，再执行以上命令。 验证配置是否成功12ssh -T git@github.com // 默认 ssh_key 验证ssh -T git@xxxgithub.com // 新的 ssh_key 验证，其中“xxx”为 config 文件中的命名 如果显示以下信息，就说明配置成功： 1Hi 你的用户名! You've successfully authenticated, but GitHub does not provide shell access. 取消全局用户名/邮箱配置，单独设置用户名/邮箱执行如下操作： 12git config --global --unset user.namegit config --global --unset user.email 分别进入两个 hexo 博客 .git 目录下执行以下命令单独设置用户名/邮箱：（.git的具体路径：\\Hexo.deploy_git.git，该目录是隐藏的） 12git config user.name &quot;这里是用户名&quot;git config user.email &quot;这里是邮箱&quot; 如果此时报错：fatal: not in a git directory，说明没有进入 .git 目录下。 执行以下命令，查看是否成功： 1git config --list 到 hexo 配置文件中填写 _config.yml 文件，在 repository 中写入: git@github.com:用户名/用户名.github.io.git 三、git 报错 ssh: connect to host github.com port 22: Connection timed out查看 SSH 是否能连接成功 1ssh -T git@xxx.github.com 如果还是报这个错，就先查看公钥文件是否存在，如果存在，则需要修改 config 内容： 12345678910111213Host xxx.github.com Hostname ssh.github.com User x@foxmail.com PreferredAuthentications publickey IdentityFile ~/.ssh/xxx port 443Host yyy.github.com HostName ssh.github.com User xx@foxmail.com PreferredAuthentications publickey IdentityFile ~/.ssh/yyy port 443 再查看是否连接成功： 1ssh -T git@xxx.github.com 出现提示直接回车 yes 即可。","link":"/49ec609a.html"},{"title":"栅格盒模型设计的精妙之处","text":"容器两边具有 15px 的 padding，行两边具有 -15px 的 margin，列两边具有 15px 的 padding。 它的精妙之处在于三点： 1、为了维护槽宽的规则 ​ 列两边必须得要 15px 的 padding 2、为了能使列嵌套行 ​ 行两边必须要有 -15px 的 padding 3、为了让容器可以包裹行 ​ 容器两边必须要有 15px 的 padding 这样才可以使得容器在行和列的嵌套下遵循设定的规则。","link":"/d8df7bb5.html"},{"title":"解决跨域问题的几个主要方案","text":"跨域就是跨资源请求，域名由协议、子域名、主域名、端口号组成，当其中任意一个不相同时，都算作不同域，不同域之间相互请求资源，即“跨域”。不过，跨域的请求可以正常发送，服务端也可以正常收到请求并返回结果，只是被浏览器拦截了。 跨域简介之所在存在跨域，是受到了同源策略的的限制，同源策略要求源相同才能正常通信，以维护资源安全，即要求协议、域名、端口号完全一致。 同源策略，就是为了隔离潜在的恶意文件对资源的侵害，它建造了一种保护用户隐私，防止读取 cookie 进行身份伪造等的安全机制。 同源策略的限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求不能发送 同时有三个标签允许跨资源请求： 123&lt;img src=&quot;xxx&quot;&gt;&lt;link href=&quot;xxx&quot;&gt;&lt;script src=&quot;xxx&quot;&gt; 跨域的解决方案1、jsonp 原理：jsonp 利用了&lt;script&gt; 标签的开放策略，可以获得 json 数据，但请求必须获得服务器支持。 优缺点： 优点是兼容性好，可以解决主流浏览器的跨域访问问题。 缺点是仅支持 get 方法，有局限性。 jsonp 的解决方案： 在客户端声明一个函数 fn，将该函数名作为参数值以 url_encode 方式传递给服务器，该函数形参作为服务器返回的数据。 创建 &lt;script&gt; 标签，直接请求数据接口地址，将定义好的函数 fn 作为参数值传递给服务器（&amp;callback=fn）。 服务器接收请求后，把客户端传递进来的 fn 与数据拼成字符串，返回给客户端。 客户端收到返回的数据后，直接进行操作。 12345// 客户端：&lt;script src=&quot;http://abc.com/jsonData?jsonp=fn&quot;&gt;&lt;/script&gt;// 服务器：返回fn([{&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 20}]) jQuery 中的 jsonp 是直接用 $.ajax() 解决的，不赘述。 2、CORS如果说 jsonp 是一种技巧的话，那 CORS 就是一种技术。 整个通信过程，不需要用户参与，浏览器自动完成。实际上，它与 ajax 同源通信没有区别，关键是服务器设置允许跨域即可。 CORS 对 IE10 以上才可以支持，兼容性不如 jsonp，但功能强大，支持各种 HTTP Method。 解决方案：服务器端设置即可 1header(&quot;Access-Control-Allow-Origin:*&quot;); header(&quot;Access-Control-Allow-Methods:POST,GET&quot;); 在响应头上添加 Access-Control-Allow-Origin 属性，指定同源策略的地址，默认是网页本身。浏览器检测到响应头上带有 CORS，并且允许的源包含本网站，就不会拦截请求响应。 3、WebSocketWebSocket 和 HTTP都是应用层协议，都基于 TCP 协议。但 WebSocket 是一种双向通信协议，在建立连接时需要借助 HTTP 协议，连接建立之后 WebSocket 的 client 和 server 就可以主动发送和接收数据了，通信时与 HTTP 无关。 Socket.io 中封装了 WebSocket 接口，增强了兼容性。 123456789101112131415161718192021222324//前端代码： &lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://www.abc.com:8080'); // 连接成功处理 socket.on('connect', function() { // 监听服务端消息 socket.on('message', function(msg) { console.log('data from server: ---&gt; ' + msg); }); // 监听服务端关闭 socket.on('disconnect', function() { console.log('Server socket has closed.'); }); }); document.getElementsByTagName('input')[0].onblur = function() { socket.send(this.value); };&lt;/script&gt; 1234567891011121314151617181920212223242526//Nodejs socket后台：var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) { res.writeHead(200, {'Content-type': 'text/html'}); res.end();});server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) { // 接收信息 client.on('message', function(msg) { client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); }); // 断开处理 client.on('disconnect', function() { console.log('Client socket has closed.'); });}); 4、postMessage使用该方法最典型的就是不同源的 iframe 窗口和 window.open 打开的窗口了，它们与父窗口无法通信。因此，HTML5 引入了一个新的 API，叫跨文档通信 API（Cross-document messaging）。这个 API 为 window 对象新增了一个 postMessage 方法，允许非同源跨窗口通信。 postMessage(data, url); // data 是具体的信息数据, url 是一个完整的接收消息的窗口的源，它可以设置为 *，表示不限制域名，向所有地方发送。 比如，某个页面向另一个页面传递跨域信息： 123456789101112131415161718//发送信息的页面 http://localhost:63342/index.html&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;跨域请求&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://localhost:3000/users/reg&quot; id=&quot;frm&quot;&gt;&lt;/iframe&gt; &lt;input type=&quot;button&quot; value=&quot;OK&quot; onclick=&quot;run()&quot;&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; function run(){ var frm=document.getElementById(&quot;frm&quot;); frm.contentWindow.postMessage(&quot;跨域请求信息&quot;,&quot;http://localhost:3000&quot;); }&lt;/script&gt; 12345//接收信息的页面 http://localhost:3000/message.htmlwindow.addEventListener(&quot;message&quot;,function(e){ //通过监听message事件，可以监听对方发送的消息。 console.log(e.data);},false); 5、降域降域只适用于同一个主域名下的不同源之间的请求。 原理：将两个域名都降域，就可以互相请求资源。即通过 js 强制设置 document.domain = 主域名。 例如：a.abc.com/a.html 获取 b.abc.com/b.html 中的 a 值。 123456789101112// a.html&lt;body&gt;&lt;iframe src=&quot;b.abc.com/b.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;frame&quot;&gt;&lt;script&gt; document.domain = &quot;abc.com&quot;; // 降域 function load() { console.log(frame.contentWindow.a); }&lt;/script&gt;&lt;/doby&gt; 1234567// b.html&lt;body&gt;&lt;script&gt; document.domain = &quot;abc.com&quot;; // 降域 let a = 100;&lt;/script&gt;&lt;/body&gt; 6、iframe 与 window.namewindow.name 可以在不同页面加载后一直存在，并且长度值最大为 2M，可以借助这个特性绕过同源策略的限制。 例如，a.html 和 b.html 同源，c.html 不同源，想请求 c 页面的数据，可以以 b 页面为中间代理页，在 a 页面中使用 iframe 跨域请求 c.html。 假如 a.html 和 b.html 同源为 localhost:3000，c 为 localhost:4000 123456789101112131415161718// a.html(http://localhost:3000/a.html)&lt;iframe src=&quot;http://localhost:4000/c.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;iframe&quot;&gt;&lt;/iframe&gt;&lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() { if(first){ // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; }else{ // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); }}&lt;/script&gt; 1234// c.html(http://localhost:4000/c.html)&lt;script&gt; window.name = '我不爱你' &lt;/script&gt; 利用 iframe 的 src 属性由跨域转向同域，跨域数据因 window.name 的特性得以保留并传递到本域。 由于 iframe 有兼容性问题，故此方法用得不多。","link":"/ab12391c.html"},{"title":"手写Promise-ES5函数版与ES6_class版","text":"自定义 Promise 的全部逻辑，并加入两个延迟执行的方法 一、ES5函数版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261/** * 自定义 Promise 函数模块: IIFE * */(function(window) { // 将经常使用的字符串用常量代替 const PENDING = 'pending' const RESOLVED = 'resolved' const REJECTED = 'rejected' /** * Promise 构造函数 * excutor: 执行器函数(同步执行) */ function Promise(excutor) { // 将当前 Promise 保存起来 const me = this me.status = PENDING // 给 promise 对象指定 status 属性，初始值为 pending me.data = undefined // 给 promise 对象指定一个用于存储结果数据的属性 me.callbacks = [] // 每个元素的结构: {onResolved() {}, onRejected() {}} function resolve(value) { // 如果当前状态不是 pending，直接结束 --- 因为 pending 只能改一次 if (me.status !== PENDING) { return } // 将状态改为 resolved me.status = RESOLVED // 保存 value me.data = value // 如果存在待执行的 callback 函数，立即异步执行回调函数 onResolved if (me.callbacks.length &gt; 0) { // 模拟异步，执行放入队列中所有成功的回调函数 setTimeout(() =&gt; { me.callbacks.forEach(callbacksObj =&gt; { callbacksObj.onResolved(value) }); }) } } function reject(reason) { // 如果当前状态不是 pending，直接结束 --- 因为 pending 只能改一次 if (me.status !== PENDING) { return } // 将状态改为 rejected me.status = REJECTED // 保存 value me.data = reason // 如果存在待执行的 callback 函数，立即异步执行回调函数 onRejected if (me.callbacks.length &gt; 0) { // 模拟异步，执行放入队列中所有成功的回调函数 setTimeout(() =&gt; { me.callbacks.forEach(callbacksObj =&gt; { callbacksObj.onRejected(reason) }); }) } } // 立即同步执行 excutor // 如果调用失败，则需捕获异常 try { excutor(resolve, reject) } catch (error) { // 如果执行器抛出异常，promise 对象变为 rejected 状态 reject(error) } } /** * Promise 原形对象的 then() * 指定成功和失败的回调函数 * 返回一个新的 Promise 对象 */ Promise.prototype.then = function(onResolved, onRejected) { onResolved = typeof onResolved === 'function' ? onResolved : value =&gt; value // 向后传递成功的 value // 指定默认的失败的回调(实现错误/异常传透的关键点) onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; { throw reason } // 向后传递失败的 reason const me = this // 返回一个新的 Promise 对象 return new Promise((resolve, reject) =&gt; { /** * 调用指定的回调函数处理，根据执行结果，改变 return 的 promise 状态 */ function handle(callback) { /** * 1.如果抛出异常，return 的 promise 就会失败，reason 就是 error * 2.如果回调函数返回不是 promise，return 的 promise 就会成功，value 就是返回值 * 3.如果回调函数返回是 promise，return 的 promise 结果就是这个 promise 的结果 */ try { const result = callback(me.data) // 3.如果回调函数返回是 promise，return 的 promise 结果就是这个 promise 的结果 if (result.instanceof(Promise)) { // result.then((resolve, reject) =&gt; { // value =&gt; resolve(value), // reason =&gt; reject(reason), // }) // 简化 result.then(resolve, reject) } else { // 2.如果回调函数返回不是 promise，return 的 promise 就会成功，value 就是返回值 resolve(result) } } catch (error) { // 1.如果抛出异常，return 的 promise 就会失败，reason 就是 error reject(error) } } // 当前还是 pending 状态，将回调函数保存起来 if (me.status === PENDING) { me.callbacks.push({ onResolved(value) { handle(onResolved) }, onRejected(reason) { handle(onRejected) } }) } else if (me.status === RESOLVED) { // 如果当前是 resolved 状态，异步执行 onResolve 并改变 return 的Promise 状态 // 回调函数需异步执行 setTimeout(() =&gt; { handle(onResolved) }) } else { // 果当前是 rejected 状态，异步执行 onRejected 并改变 return 的 Promise 状态 // 回调函数需异步执行 setTimeout(() =&gt; { handle(onRejected) }) } }) } /** * Promise 原形对象的 catch() * 指定失败的回调函数 * 返回一个新的 Promise 对象 */ Promise.prototype.catch = function(onRejected) { return this.then(undefined, onRejected) } /** * Promise 函数对象的 resolve 方法 * 返回一个指定结果的成功的 Promise */ Promise.resolve = function(value) { // 返回一个成功/失败的 promise return new Promise((resolve, reject) =&gt; { // value 是 promise时 if (value instanceof(Promise)) { // 使用 value 的结果作为 promise 的结果 value.then(resolve, reject) } else { // value 不是 promise 时，promise 成功，数据是 value resolve(value) } }) } /** * Promise 函数对象的 reject方法 * 返回一个指定 reason 的失败的 Promise */ Promise.reject = function(reason) { return new Promise((resolve, reject) =&gt; { reject(reason) }) } /** * Promise 函数对象的 all 方法 * 返回一个 promise，只有当所有的 promise 都成功时才成功，否则只要有一个失败的就失败 */ Promise.all = function(promises) { // 用来保存所有成功 value 的数组 const values = new Array(promises.length) // 用来保存成功的 promise 的数量 let resolvedCount = 0 // 返回一个新的 promise return new Promise((resolve, reject) =&gt; { // 遍历 promises 获取每个 promise 的结果 promises.forEach((p, index) =&gt; { Promise.resolve(p).then( value =&gt; { resolvedCount++ // 成功的数量加1 // p 成功，将成功的 value 保存到 values // value.push(p) // 不行,成功的 promise 的顺序也必须是一一对应的 values[index] = value // 如果全部成功了，将return的promise改为成功 if (resolvedCount === promises.length) { resolve(values) } }, reason =&gt; { // 只要一个失败了，return 的 promise 就会失败 reject(reason) } ) }) }) } /** * Promise 函数对象的 race 方法 * 返回一个 promise，其结果由第一个完成的 promise 决定 */ Promise.race = function(promises) { // 返回一个 promise return new Promise((resolve, reject) =&gt; { // 遍历 promises 获取每个 promise 的结果 promises.forEach((p, index) =&gt; { Promise.resolve(p).then( value =&gt; { // 一旦有成功的，将 return 变为成功 resolve(value) }, reason =&gt; { // 只要一个失败了，return 的 promise 就会失败 reject(reason) } ) }) }) } /** * 工具方法 --- resolveDelay(自定义方法) * 每返回一个 promise 对象，它在指定的时间后才确定结果 */ Promise.resolveDelay = function(value, time) { // 返回一个成功/失败的 promise return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // value 是 promise if (value instanceof(Promise)) { // 使用 value 的结果作为 promise 的结果 value.then(resolve, reject) } else { // value 不是 promise =&gt; promise 变为成功，数据是 value resolve(value) } }, time); }) } /** * 工具方法 --- rejectDelay(自定义方法) * 每返回一个 promise 对象，它在指定的时间后才失败 */ Promise.rejectDelay = function(reason, time) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(reason) }, time); }) } // 向外暴露 Promise 函数 window.Promise = Promise})(window) 二、ES6 class版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266/** * 自定义 Promise 函数模块: class * */(function(window) { // 将经常使用的字符串用常量代替 const PENDING = 'pending' const RESOLVED = 'resolved' const REJECTED = 'rejected' class Promise { /** * Promise 构造函数 * excutor: 执行器函数(同步执行) */ constructor(excutor) { // 将当前 Promise 保存起来 const me = this me.status = PENDING // 给 promise 对象指定 status 属性，初始值为 pending me.data = undefined // 给 promise 对象指定一个用于存储结果数据的属性 me.callbacks = [] // 每个元素的结构: {onResolved() {}, onRejected() {}} function resolve(value) { // 如果当前状态不是 pending，直接结束 --- 因为 pending 只能改一次 if (me.status !== PENDING) { return } // 将状态改为 resolved me.status = RESOLVED // 保存 value me.data = value // 如果存在待执行的 callback 函数，立即异步执行回调函数 onResolved if (me.callbacks.length &gt; 0) { // 模拟异步，执行放入队列中所有成功的回调函数 setTimeout(() =&gt; { me.callbacks.forEach(callbacksObj =&gt; { callbacksObj.onResolved(value) }); }) } } function reject(reason) { // 如果当前状态不是 pending，直接结束 --- 因为 pending 只能改一次 if (me.status !== PENDING) { return } // 将状态改为 rejected me.status = REJECTED // 保存 value me.data = reason // 如果存在待执行的 callback 函数，立即异步执行回调函数 onRejected if (me.callbacks.length &gt; 0) { // 模拟异步，执行放入队列中所有成功的回调函数 setTimeout(() =&gt; { me.callbacks.forEach(callbacksObj =&gt; { callbacksObj.onRejected(reason) }); }) } } // 立即同步执行 excutor // 如果调用失败，则需捕获异常 try { excutor(resolve, reject) } catch (error) { // 如果执行器抛出异常，promise 对象变为 rejected 状态 reject(error) } } /** * Promise 原形对象的 then() * 指定成功和失败的回调函数 * 返回一个新的 Promise 对象 */ then(onResolved, onRejected) { onResolved = typeof onResolved === 'function' ? onResolved : value =&gt; value // 向后传递成功的 value // 指定默认的失败的回调(实现错误/异常传透的关键点) onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; { throw reason } // 向后传递失败的 reason const me = this // 返回一个新的 Promise 对象 return new Promise((resolve, reject) =&gt; { /** * 调用指定的回调函数处理，根据执行结果，改变 return 的 promise状态 */ function handle(callback) { /** * 1.如果抛出异常，return 的 promise 就会失败，reason 就是 error * 2.如果回调函数返回不是 promise，return 的 promise 就会成功，value 就是返回值 * 3.如果回调函数返回是 promise，return 的 promise 结果就是这个 promise 的结果 */ try { const result = callback(me.data) // 3.如果回调函数返回是 promise，return 的 promise 结果就是这个 promise 的结果 if (result.instanceof(Promise)) { // result.then((resolve, reject) =&gt; { // value =&gt; resolve(value), // reason =&gt; reject(reason), // }) // 简化 result.then(resolve, reject) } else { // 2.如果回调函数返回不是 promise，return 的 promise 就会成功，value 就是返回值 resolve(result) } } catch (error) { // 1.如果抛出异常，return 的 promise 就会失败，reason 就是 error reject(error) } } // 当前还是 pending 状态，将回调函数保存起来 if (me.status === PENDING) { me.callbacks.push({ onResolved(value) { handle(onResolved) }, onRejected(reason) { handle(onRejected) } }) } else if (me.status === RESOLVED) { // 如果当前是 resolved 状态，异步执行 onResolve 并改变 return的 Promise 状态 // 回调函数需异步执行 setTimeout(() =&gt; { handle(onResolved) }) } else { // 果当前是 rejected 状态，异步执行 onRejected 并改变 return 的 Promise 状态 // 回调函数需异步执行 setTimeout(() =&gt; { handle(onRejected) }) } }) } /** * Promise 原形对象的 catch() * 指定失败的回调函数 * 返回一个新的 Promise 对象 */ catch (onRejected) { return this.then(undefined, onRejected) } /** * Promise 函数对象的 resolve 方法 * 返回一个指定结果的成功的 Promise * * 注: 给类对象添加方法 * 在函数前加上 static */ static resolve = function(value) { // 返回一个成功/失败的 promise return new Promise((resolve, reject) =&gt; { // value 是 promise时 if (value instanceof(Promise)) { // 使用 value 的结果作为 promise 的结果 value.then(resolve, reject) } else { // value 不是 promise 时，promise 成功，数据是 value resolve(value) } }) } /** * Promise 函数对象的 reject 方法 * 返回一个指定 reason 的失败的 Promise */ static reject = function(reason) { return new Promise((resolve, reject) =&gt; { reject(reason) }) } /** * Promise 函数对象的 all 方法 * 返回一个 promise，只有当所有的 promise 都成功时才成功，否则只要有一个失败的就失败 */ static all = function(promises) { // 用来保存所有成功 value 的数组 const values = new Array(promises.length) // 用来保存成功的 promise 的数量 let resolvedCount = 0 // 返回一个新的 promise return new Promise((resolve, reject) =&gt; { // 遍历 promises 获取每个 promise 的结果 promises.forEach((p, index) =&gt; { Promise.resolve(p).then( value =&gt; { resolvedCount++ // 成功的数量加1 // p 成功，将成功的 value 保存到 values // value.push(p) // 不行,成功的 promise 的顺序也必须是一一对应的 values[index] = value // 如果全部成功了，将 return 的 promise 改为成功 if (resolvedCount === promises.length) { resolve(values) } }, reason =&gt; { // 只要一个失败了，return 的 promise 就会失败 reject(reason) } ) }) }) } /** * Promise 函数对象的 race 方法 * 返回一个 promise，其结果由第一个完成的 promise 决定 */ static race = function(promises) { // 返回一个 promise return new Promise((resolve, reject) =&gt; { // 遍历 promises 获取每个 promise 的结果 promises.forEach((p, index) =&gt; { Promise.resolve(p).then( value =&gt; { // 一旦有成功的，将 return 变为成功 resolve(value) }, reason =&gt; { // 只要一个失败了，return 的 promise 就会失败 reject(reason) } ) }) }) } /** * 工具方法 --- resolveDelay(自定义方法) * 每返回一个 promise 对象，它在指定的时间后才确定结果 */ static resolveDelay = function(value, time) { // 返回一个成功/失败的 promise return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // value 是 promise if (value instanceof(Promise)) { // 使用 value 的结果作为 promise 的结果 value.then(resolve, reject) } else { // value 不是 promise =&gt; promise 变为成功，数据是 value resolve(value) } }, time); }) } /** * 工具方法 --- rejectDelay(自定义方法) * 每返回一个 promise 对象，它在指定的时间后才失败 */ static rejectDelay = function(reason, time) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(reason) }, time); }) } } // 向外暴露 Promise 函数 window.Promise = Promise})(window)","link":"/32a89cf3.html"}],"tags":[{"name":"sublime text3","slug":"sublime-text3","link":"/tags/sublime-text3/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"cases","slug":"cases","link":"/tags/cases/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"h5","slug":"h5","link":"/tags/h5/"},{"name":"zepto.js","slug":"zepto-js","link":"/tags/zepto-js/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"异步","slug":"异步","link":"/tags/%E5%BC%82%E6%AD%A5/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"},{"name":"跨域","slug":"跨域","link":"/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"}],"categories":[{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"html5&amp;css3","slug":"html5-css3","link":"/categories/html5-css3/"},{"name":"无常小记","slug":"无常小记","link":"/categories/%E6%97%A0%E5%B8%B8%E5%B0%8F%E8%AE%B0/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"}]}