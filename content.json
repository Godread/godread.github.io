{"pages":[],"posts":[{"title":"canvas钟表","text":"canvas可以绘制很多图形，这个实例绘制的是一个对准当前时间的钟表。其组成是：外层空心圆盘、时针刻度、时针、分针、秒针、表座、秒头。绘制时注意清除每次叠加的图形。 css部分12345678910111213141516171819* { margin: 0; padding: 0;}html,body { height: 100%; overflow: hidden; background: pink;}#clock { background: gray; position: absolute; top: 50%; left: 50%; transform: translate3d(-50%, -50%, 0);} html部分1234&lt;h2 align=&quot;center&quot; style=&quot;margin-top: 100px; color: blue;&quot;&gt;canvas-时针&lt;/h2&gt;&lt;canvas id=&quot;clock&quot; width=&quot;400&quot; height=&quot;400&quot;&gt; &lt;span&gt;你的浏览器不支持 canvas 元素,请升级当前浏览器或使用其他主流浏览器&lt;/span&gt;&lt;/canvas&gt; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111window.onload = function() { var clock = document.getElementById('clock'); if (clock.getContext) { var ctx = clock.getContext('2d'); setInterval(() =&gt; { // 清除每次叠加的图形 ctx.clearRect(0, 0, clock.width, clock.height); clockMove(); }, 1000); clockMove(); function clockMove() { // 初始化 ctx.save(); ctx.lineWidth = 8; ctx.strokeStyle = 'black'; ctx.lineCap = 'round'; ctx.translate(200, 200); ctx.rotate(-90 * Math.PI / 180); ctx.beginPath(); // 外层空心圆盘 ctx.save(); ctx.strokeStyle = '#325fa2'; ctx.lineWidth = 14; ctx.beginPath(); ctx.arc(0, 0, 140, 0, 360 * Math.PI / 180); ctx.stroke(); ctx.restore(); // 时针刻度 ctx.save(); for (var i = 0; i &lt; 12; i++) { ctx.beginPath(); ctx.moveTo(100, 0); ctx.lineTo(120, 0); ctx.rotate(30 * Math.PI / 180); ctx.stroke(); } ctx.restore(); // 分针刻度 ctx.save(); ctx.lineWidth = 4; for (var i = 0; i &lt; 60; i++) { if (i % 5 != 0) { ctx.beginPath(); ctx.moveTo(117, 0); ctx.lineTo(120, 0); ctx.stroke(); } ctx.rotate(6 * Math.PI / 180); } ctx.restore(); // 时针、分针、秒针、表座、秒头 var date = new Date(); var s = date.getSeconds(); var m = date.getMinutes(); var h = date.getHours(); h = h &gt; 12 ? h - 12 : h; // 时针 ctx.save(); ctx.lineWidth = 14; ctx.rotate(h * 30 * Math.PI / 180); ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(80, 0); ctx.stroke(); ctx.restore(); // 分针 ctx.save(); ctx.lineWidth = 10; ctx.rotate(m * 6 * Math.PI / 180); ctx.beginPath(); ctx.moveTo(-28, 0); ctx.lineTo(112, 0); ctx.stroke(); ctx.restore(); // 秒针 ctx.save(); ctx.lineWidth = 6; ctx.strokeStyle = '#d40000'; ctx.fillStyle = '#d40000'; ctx.rotate(s * 6 * Math.PI / 180); ctx.beginPath(); ctx.moveTo(-30, 0); ctx.lineTo(83, 0); ctx.stroke(); // 表座 ctx.beginPath(); ctx.arc(0, 0, 10, 0, 360 * Math.PI / 180); ctx.fill(); // 秒头 ctx.beginPath(); ctx.arc(96, 0, 10, 0, 360 * Math.PI / 180); ctx.stroke(); ctx.restore(); ctx.restore(); } }}","link":"/godread.github.io/8f5b3dc2.html"},{"title":"sublime配置less编译环境","text":"Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。Less 可以运行在 Node 或浏览器端。 一、确认是否已安装 node.js二、安装 npm 或 cnpm(此步可略过)如果 npm 安装失败，可使用 cnpm。命令行输入 1npm install -g cnpm --registry=https://registry.npm.taobao.org 等待安装完成。 三、全局安装 less(提示：如果npm安装失败，请尝试使用cnpm安装，方法与npm相同，将那npm替换为cnpm即可)命令行输入： 1npm install less -g 检查less环境是否配置完成，命令行输入： 1lessc -v 看是否能正确打印版本号。 四、继续安装命令行输入： 1npm install less-plugin-clean-css -g 五、在 sublime 安装插件 less2Css通过 package install 安装即可。 此时，创建的 less 文件在保存时可自动编译为相同名称的 css 文件。 另外有 koala app 可以直接编译 less 文件，而不必在 sublime 中安装插件去官网下载 koala app","link":"/godread.github.io/725c7ed5.html"},{"title":"zepto.js 简单的可无限增加内容的 h5 滑屏效果","text":"一个简单的 h5 页面，利用了 zepto.js 的一些 api，可以初步窥探 h5 效果的制作方式。其中尤其要注意的是滑动时的白页面问题，这与文档的结构有关，因此做了自动数量判断，用以解决对应序列页面的显隐。 页面在滑动时，会滑动到相应次序的页面，如下图所示 引入 css/js12345678*按文档结构安排路径*&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt; // 基础配置 css&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt; // 静态页面 css&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/animation.css&quot;&gt; // 动画 css&lt;script src=&quot;../node_modules/zepto/dist/zepto.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../node_modules/zepto/src/touch.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/index.js&quot;&gt;&lt;/script&gt; // 滑动逻辑 文档的结构是这样的：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;page-group pg-group1 page-current&quot; data-row=&quot;1&quot;&gt; &lt;div class=&quot;page page-1-1 page-current&quot;&gt; &lt;img class=&quot;img_1 pt-page-moveFromTop&quot; src=&quot;./images/page1_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 pt-page-moveFromLeft&quot; src=&quot;./images/page1_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;common_img pt-page-moveIconUp&quot; src=&quot;./images/page_up.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;page-group pg-group2 hide&quot; data-row=&quot;2&quot;&gt; &lt;div class=&quot;page page-2-1 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-moveFromBottom&quot; src=&quot;./images/page2-1_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-moveCircle&quot; src=&quot;./images/page2-1_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_3 hide pt-page-moveFromLeft&quot; src=&quot;./images/page2-1_3.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_4 hide pt-page-scaleUp&quot; src=&quot;./images/page2-1_4.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;common_img hide pt-page-moveIconUp&quot; src=&quot;./images/page_up.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;page page-2-2 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-flipInLeft&quot; src=&quot;./images/page2-2_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-flipInLeft&quot; src=&quot;./images/page2-2_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;common_img hide pt-page-moveIconUp&quot; src=&quot;./images/page_up.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;page-group pg-group3 hide&quot; data-row=&quot;2&quot;&gt; &lt;div class=&quot;page page-3-1 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-moveFromTop&quot; src=&quot;./images/page3-1_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-moveCircle&quot; src=&quot;./images/page3-1_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_3 hide pt-page-moveFromRight&quot; src=&quot;./images/page3-1_3.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_4 hide pt-page-scaleUp&quot; src=&quot;./images/page2-1_4.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;page page-3-2 hide&quot;&gt; &lt;img class=&quot;img_1 hide pt-page-moveFromBottom&quot; src=&quot;./images/page3-2_1.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_2 hide pt-page-moveCircle&quot; src=&quot;./images/page3-2_2.png&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;img_3 hide pt-page-moveToLeft&quot; src=&quot;./images/page3-2_3.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; ......可以增加更多内页面组&lt;/div&gt; 公共图标就是底部的箭头图标，这些都可以自定义去留。 初始化数据1、滑动方向h5 页面的滑动不外乎四个方向，因此，在初始化数据时，定义一个变量，表示四个滑动方向 1let direction = {up: 1, right: 2, down: 3, left: 4}; 2、横纵方向的两个坐标还要初始化两个坐标，分别表示纵向滑动的页面和横向滑动的页面 12let last = {col: 0, row: 0}; // 表示出场页面let now = {col: 1, row: 1}; // 表示入场页面 3、判断页面是否在滑动状态另外需注意的是，在滑动时，如果操作过快，会导致入场页面还没有稳定展示就迅速出场，为了防止这种情况，需要在滑动时判断当前页面是否在滑动的状态中 1let isMoving = false; // 默认为 false,即没有滑动 4、计算文档中共有几个层级的主页面即计算纵向有几个主页面，横向页面为纵向页面的子页面 1let mainPage = $(&quot;.page-group&quot;).length; 滑动事件也即四个方向上的滑动事件，向上、向下、向左、向右。 1、向上滑动向上滑动时，计算滑动时出场、入场页面的坐标，并判断是否有相应坐标的入场页面存在，如果存在就入场，如果不存在就保持当前页面不动。 需注意：要先判断入场主页面的子页数量，以进入相应的页面。比如，page-2-2 上滑进入 page-3-2，一一对应。 123456789101112131415161718192021222324252627$(&quot;.page&quot;).on(&quot;swipeUp&quot;, function () { // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; if (last.col &lt; mainPage) { // 判断要出场的页面是否存在 // 获取要出场的页面的最大序号 let nowRow = $(this).parent('.page-group').next().attr('data-row'); // 当要出场页面的最大序号小于当前页面,即说明该出场页面不存在,禁止滑动 if (nowRow &lt; last.row) { return; } // 计算滑动之后进场页面的坐标 now.col = last.col + 1; now.row = last.row; movePage(direction.up); }}) 2、向下滑动逻辑与向下滑动类似 1234567891011121314151617181920212223242526272829// 向下滑动$(&quot;.page&quot;).on(&quot;swipeDown&quot;, function () { let _this = $(this); // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; if (last.col &gt; 1) { // 判断要出场的页面是否存在 // 获取要出场的页面的最大序号 let lastRow = $(this).parent('.page-group').prev().attr('data-row'); // 当要出场页面的最大序号小于当前页面,即说明该出场页面不存在,禁止滑动 if (lastRow &lt; now.row) { return; } // 计算滑动之后进场页面的坐标 now.col = last.col - 1; now.row = last.row; movePage(direction.down); }}); 3、向左滑动向左右滑动时，要注意是否会出现空白页，因此需要获取当前主页面的子页数量。由于出场页面是从 0 开始算的，但页面和 css 的命名都是从 1 开始的，因此滑动坐标需 &gt;1，同时 &lt;= mainPage(当前组的页面数量)。 12345678910111213141516171819202122232425// 向左滑动$(&quot;.page&quot;).on(&quot;swipeLeft&quot;, function () { // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; // 获取当前页面组的数量 let maxPage = $(this).parent(&quot;.page-group&quot;).attr(&quot;data-row&quot;); if (last.col &gt; 1 &amp;&amp; last.col &lt;= mainPage) { // 如果要出场的页面序号小于当前的页面数量,即滑动,否则不动 if (last.row &lt; maxPage) { // 计算滑动之后进场页面的坐标 now.col = last.col; now.row = last.row + 1; movePage(direction.left); } }}); 4、向右滑动与向左类似 12345678910111213141516171819202122// 向右滑动$(&quot;.page&quot;).on(&quot;swipeRight&quot;, function () { // 判断页面是否在滑动中 if (isMoving) { return; // 在滑动中则当前滑动不生效 } // 计算滑动之后 lastPage 页面的坐标 last.col = now.col; last.row = now.row; if (last.col &gt; 1 &amp;&amp; last.col &lt;= mainPage &amp;&amp; last.row &gt; 0) { // 如果当前页面序号大于1(使 now.row 不能等于1),则可以滑动,否则,不滑动 if (last.row &gt; 1) { // 计算滑动之后进场页面的坐标 now.col = last.col; now.row = last.row - 1; movePage(direction.right); } }}); 定义一个滑动函数四个方向的滑动都需要用到这个函数。 页面滑动时，出入场页面增加或移除相应的样式，匹配相应的方向，表示显隐状态。 页面中的每一个图片都要在初始状态隐藏(.hide {display: none;})，这样就不会在页面没有显示时就完成了过渡效果。 在滑动完成后，出场页面图片会停留在当前页面，因此需要在动画执行完成后进行清除，即隐藏。 要注意动画执行完成后，调整页面滑动状态 isMoving。 实际上就是根据方向匹配相应的 css 过渡动画，执行显隐状态的切换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 定义一个滑动的功能函数function movePage(dir) { // 初始化参与动画的页面 let lastPage = &quot;.page-&quot; + last.col + &quot;-&quot; + last.row; let nowPage = &quot;.page-&quot; + now.col + &quot;-&quot; + now.row; // 初始两个动画类 let inClass = &quot;&quot; // 进场动画类 let outClass = &quot;&quot; // 出场动画类 // 匹配方向 switch (dir) { case direction.up: outClass = &quot;pt-page-moveToTop&quot;; inClass = &quot;pt-page-moveFromBottom&quot;; break; case direction.right: outClass = &quot;pt-page-moveToRight&quot;; inClass = &quot;pt-page-moveFromLeft&quot;; break; case direction.bottom: outClass = &quot;pt-page-moveToBottom&quot;; inClass = &quot;pt-page-moveFromTop&quot;; break; case direction.left: outClass = &quot;pt-page-moveToLeft&quot;; inClass = &quot;pt-page-moveFromRight&quot;; break; } // 将动画类加到参与动画的页面上 $(lastPage).addClass(outClass).addClass(&quot;hide&quot;); $(nowPage).removeClass(&quot;hide&quot;).addClass(inClass); // 滑动时设置当前滑动状态为 true isMoving = true; // 动画执行完清除动画类 setTimeout(function () { $(lastPage).find(&quot;img&quot;).addClass(&quot;hide&quot;); $(lastPage).removeClass(outClass).removeClass(&quot;page-current&quot;).addClass(&quot;hide&quot;); $(lastPage).parent('.page-group').removeClass('page-current').addClass('hide'); $(nowPage).parent('.page-group').removeClass('hide').addClass('page-current'); $(nowPage).find(&quot;img&quot;).removeClass(&quot;hide&quot;); $(nowPage).removeClass(&quot;hide&quot;).addClass(&quot;page-current&quot;).removeClass(inClass); // 动画执行完停止滑动状态 isMoving = false; }, 600);} 最后要注意的是，禁止页面的默认触摸事件，在 css 中的 .page 里设置 touch-action: none 即可。 完整的项目：zeptojs-h5","link":"/godread.github.io/da582b16.html"},{"title":"栅格盒模型设计的精妙之处","text":"容器两边具有 15px 的 padding，行两边具有 -15px 的 margin，列两边具有 15px 的 padding。 它的精妙之处在于三点： 1、为了维护槽宽的规则 ​ 列两边必须得要 15px 的 padding 2、为了能使列嵌套行 ​ 行两边必须要有 -15px 的 padding 3、为了让容器可以包裹行 ​ 容器两边必须要有 15px 的 padding 这样才可以使得容器在行和列的嵌套下遵循设定的规则。","link":"/godread.github.io/d8df7bb5.html"},{"title":"解决跨域问题的几个主要方案","text":"跨域就是跨资源请求，域名由协议、子域名、主域名、端口号组成，当其中任意一个不相同时，都算作不同域，不同域之间相互请求资源，即“跨域”。不过，跨域的请求可以正常发送，服务端也可以正常收到请求并返回结果，只是被浏览器拦截了。 跨域简介之所在存在跨域，是受到了同源策略的的限制，同源策略要求源相同才能正常通信，以维护资源安全，即要求协议、域名、端口号完全一致。 同源策略，就是为了隔离潜在的恶意文件对资源的侵害，它建造了一种保护用户隐私，防止读取 cookie 进行身份伪造等的安全机制。 同源策略的限制内容有： Cookie、LocalStorage、IndexedDB等存储性内容 DOM 节点 AJAX 请求不能发送 同时有三个标签允许跨资源请求： 123&lt;img src=&quot;xxx&quot;&gt;&lt;link href=&quot;xxx&quot;&gt;&lt;script src=&quot;xxx&quot;&gt; 跨域的解决方案1、jsonp 原理：jsonp 利用了&lt;script&gt; 标签的开放策略，可以获得 json 数据，但请求必须获得服务器支持。 优缺点： 优点是兼容性好，可以解决主流浏览器的跨域访问问题。 缺点是仅支持 get 方法，有局限性。 jsonp 的解决方案： 在客户端声明一个函数 fn，将该函数名作为参数值以 url_encode 方式传递给服务器，该函数形参作为服务器返回的数据。 创建 &lt;script&gt; 标签，直接请求数据接口地址，将定义好的函数 fn 作为参数值传递给服务器（&amp;callback=fn）。 服务器接收请求后，把客户端传递进来的 fn 与数据拼成字符串，返回给客户端。 客户端收到返回的数据后，直接进行操作。 12345// 客户端：&lt;script src=&quot;http://abc.com/jsonData?jsonp=fn&quot;&gt;&lt;/script&gt;// 服务器：返回fn([{&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 20}]) jQuery 中的 jsonp 是直接用 $.ajax() 解决的，不赘述。 2、CORS如果说 jsonp 是一种技巧的话，那 CORS 就是一种技术。 整个通信过程，不需要用户参与，浏览器自动完成。实际上，它与 ajax 同源通信没有区别，关键是服务器设置允许跨域即可。 CORS 对 IE10 以上才可以支持，兼容性不如 jsonp，但功能强大，支持各种 HTTP Method。 解决方案：服务器端设置即可 1header(&quot;Access-Control-Allow-Origin:*&quot;); header(&quot;Access-Control-Allow-Methods:POST,GET&quot;); 在响应头上添加 Access-Control-Allow-Origin 属性，指定同源策略的地址，默认是网页本身。浏览器检测到响应头上带有 CORS，并且允许的源包含本网站，就不会拦截请求响应。 3、WebSocketWebSocket和HTTP都是应用层协议，都基于 TCP 协议。但 WebSocket 是一种双向通信协议，在建立连接时需要借助 HTTP 协议，连接建立之后 WebSocket 的 client 和 server 就可以主动发送和接收数据了，通信时与 HTTP 无关。 Socket.io 中封装了 WebSocket 接口，增强了兼容性。 123456789101112131415161718192021222324//前端代码： &lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://www.abc.com:8080'); // 连接成功处理 socket.on('connect', function() { // 监听服务端消息 socket.on('message', function(msg) { console.log('data from server: ---&gt; ' + msg); }); // 监听服务端关闭 socket.on('disconnect', function() { console.log('Server socket has closed.'); }); }); document.getElementsByTagName('input')[0].onblur = function() { socket.send(this.value); };&lt;/script&gt; 1234567891011121314151617181920212223242526//Nodejs socket后台：var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) { res.writeHead(200, {'Content-type': 'text/html'}); res.end();});server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) { // 接收信息 client.on('message', function(msg) { client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); }); // 断开处理 client.on('disconnect', function() { console.log('Client socket has closed.'); });}); 4、postMessage使用该方法最典型的就是不同源的 iframe 窗口和 window.open 打开的窗口了，它们与父窗口无法通信。因此，HTML5 引入了一个新的 API，叫跨文档通信 API（Cross-document messaging）。这个 API 为 window 对象新增了一个 postMessage 方法，允许非同源跨窗口通信。 postMessage(data, url); // data 是具体的信息数据, url 是一个完整的接收消息的窗口的源,它可以设置为 *，表示不限制域名，向所有窜发送。 比如，某个页面向另一个页面传递跨域信息： 123456789101112131415161718//发送信息的页面 http://localhost:63342/index.html&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;跨域请求&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://localhost:3000/users/reg&quot; id=&quot;frm&quot;&gt;&lt;/iframe&gt; &lt;input type=&quot;button&quot; value=&quot;OK&quot; onclick=&quot;run()&quot;&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; function run(){ var frm=document.getElementById(&quot;frm&quot;); frm.contentWindow.postMessage(&quot;跨域请求信息&quot;,&quot;http://localhost:3000&quot;); }&lt;/script&gt; 12345//接收信息的页面 http://localhost:3000/message.htmlwindow.addEventListener(&quot;message&quot;,function(e){ //通过监听message事件，可以监听对方发送的消息。 console.log(e.data);},false); 5、降域降域只适用于同一个主域名下的不同源之间的请求。 原理：将两个域名都降域，就可以互相请求资源。即通过 js 强制设置 document.domain = 主域名。 例如：a.abc.com/a.html 获取 b.abc.com/b.html 中的 a 值。 123456789101112// a.html&lt;body&gt;&lt;iframe src=&quot;b.abc.com/b.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;frame&quot;&gt;&lt;script&gt; document.domain = &quot;abc.com&quot;; // 降域 function load() { console.log(frame.contentWindow.a); }&lt;/script&gt;&lt;/doby&gt; 1234567// b.html&lt;body&gt;&lt;script&gt; document.domain = &quot;abc.com&quot;; // 降域 let a = 100;&lt;/script&gt;&lt;/body&gt; 6、iframe 与 window.namewindow.name 可以在不同页面加载后一直存在，并且长度值最大为 2M，可以借助这个特性绕过同源策略的限制。 例如，a.html 和 b.html 同源，c.html 不同源，想请求 c 页面的数据，可以以 b 页面为中间代理页，在 a 页面中使用 iframe 跨域请求 c.html。 假如 a.html 和 b.html 同源为 localhost:3000，c 为 localhost:4000 123456789101112131415161718// a.html(http://localhost:3000/a.html)&lt;iframe src=&quot;http://localhost:4000/c.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;iframe&quot;&gt;&lt;/iframe&gt;&lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() { if(first){ // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; }else{ // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); }}&lt;/script&gt; 1234// c.html(http://localhost:4000/c.html)&lt;script&gt; window.name = '我不爱你' &lt;/script&gt; 利用 iframe 的 src 属性由跨域转向同域，跨域数据因 window.name 的特性得以保留并传递到本域。 由于 iframe 有兼容性问题，故此方法用得不多。","link":"/godread.github.io/ab12391c.html"},{"title":"手写Promise-ES5函数版与ES6_class版","text":"自定义Promise的全部逻辑，并加入两个延迟执行的方法 一、ES5函数版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261/** * 自定义Promise函数模块: IIFE * */(function(window) { // 将经常使用的字符串用常量代替 const PENDING = 'pending' const RESOLVED = 'resolved' const REJECTED = 'rejected' /** * Promise构造函数 * excutor: 执行器函数(同步执行) */ function Promise(excutor) { // 将当前Promise保存起来 const me = this me.status = PENDING // 给promise对象指定status属性，初始值为pending me.data = undefined // 给promise对象指定一个用于存储结果数据的属性 me.callbacks = [] // 每个元素的结构: {onResolved() {}, onRejected() {}} function resolve(value) { // 如果当前状态不是pending，直接结束 --- 因为pending只能改一次 if (me.status !== PENDING) { return } // 将状态改为resolved me.status = RESOLVED // 保存value me.data = value // 如果存在待执行的callback函数，立即异步执行回调函数onResolved if (me.callbacks.length &gt; 0) { // 模拟异步，执行放入队列中所有成功的回调函数 setTimeout(() =&gt; { me.callbacks.forEach(callbacksObj =&gt; { callbacksObj.onResolved(value) }); }) } } function reject(reason) { // 如果当前状态不是pending，直接结束 --- 因为pending只能改一次 if (me.status !== PENDING) { return } // 将状态改为rejected me.status = REJECTED // 保存value me.data = reason // 如果存在待执行的callback函数，立即异步执行回调函数onRejected if (me.callbacks.length &gt; 0) { // 模拟异步，执行放入队列中所有成功的回调函数 setTimeout(() =&gt; { me.callbacks.forEach(callbacksObj =&gt; { callbacksObj.onRejected(reason) }); }) } } // 立即同步执行excutor // 如果调用失败，则需捕获异常 try { excutor(resolve, reject) } catch (error) { // 如果执行器抛出异常，promise对象变为rejected状态 reject(error) } } /** * Promise原形对象的then() * 指定成功和失败的回调函数 * 返回一个新的Promise对象 */ Promise.prototype.then = function(onResolved, onRejected) { onResolved = typeof onResolved === 'function' ? onResolved : value =&gt; value // 向后传递成功的value // 指定默认的失败的回调(实现错误/异常传透的关键点) onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; { throw reason } // 向后传递失败的reason const me = this // 返回一个新的Promise对象 return new Promise((resolve, reject) =&gt; { /** * 调用指定的回调函数处理，根据执行结果，改变return的promise状态 */ function handle(callback) { /** * 1.如果抛出异常，return的promise就会失败，reason就是error * 2.如果回调函数返回不是promise，return的promise就会成功，value就是返回值 * 3.如果回调函数返回是promise，return的promise结果就是这个promise的结果 */ try { const result = callback(me.data) // 3.如果回调函数返回是promise，return的promise结果就是这个promise的结果 if (result.instanceof(Promise)) { // result.then((resolve, reject) =&gt; { // value =&gt; resolve(value), // reason =&gt; reject(reason), // }) // 简化 result.then(resolve, reject) } else { // 2.如果回调函数返回不是promise，return的promise就会成功，value就是返回值 resolve(result) } } catch (error) { // 1.如果抛出异常，return的promise就会失败，reason就是error reject(error) } } // 当前还是pending状态，将回调函数保存起来 if (me.status === PENDING) { me.callbacks.push({ onResolved(value) { handle(onResolved) }, onRejected(reason) { handle(onRejected) } }) } else if (me.status === RESOLVED) { // 如果当前是resolved状态，异步执行onResolve并改变return的Promise状态 // 回调函数需异步执行 setTimeout(() =&gt; { handle(onResolved) }) } else { // 果当前是rejected状态，异步执行onRejected并改变return的Promise状态 // 回调函数需异步执行 setTimeout(() =&gt; { handle(onRejected) }) } }) } /** * Promise原形对象的catch() * 指定失败的回调函数 * 返回一个新的Promise对象 */ Promise.prototype.catch = function(onRejected) { return this.then(undefined, onRejected) } /** * Promise函数对象的resolve方法 * 返回一个指定结果的成功的Promise */ Promise.resolve = function(value) { // 返回一个成功/失败的promise return new Promise((resolve, reject) =&gt; { // value是promise时 if (value instanceof(Promise)) { // 使用value的结果作为promise的结果 value.then(resolve, reject) } else { // value不是promise时，promise成功，数据是value resolve(value) } }) } /** * Promise函数对象的reject方法 * 返回一个指定reason的失败的Promise */ Promise.reject = function(reason) { return new Promise((resolve, reject) =&gt; { reject(reason) }) } /** * Promise函数对象的all方法 * 返回一个promise，只有当所有的promise都成功时才成功，否则只要有一个失败的就失败 */ Promise.all = function(promises) { // 用来保存所有成功value的数组 const values = new Array(promises.length) // 用来保存成功的promise的数量 let resolvedCount = 0 // 返回一个新的promise return new Promise((resolve, reject) =&gt; { // 遍历promises获取每个promise的结果 promises.forEach((p, index) =&gt; { Promise.resolve(p).then( value =&gt; { resolvedCount++ // 成功的数量加1 // p成功，将成功的value保存到values // value.push(p) // 不行,成功的promise的顺序也必须是一一对应的 values[index] = value // 如果全部成功了，将return的promise改为成功 if (resolvedCount === promises.length) { resolve(values) } }, reason =&gt; { // 只要一个失败了，return的promise就会失败 reject(reason) } ) }) }) } /** * Promise函数对象的race方法 * 返回一个promise，其结果由第一个完成的promise决定 */ Promise.race = function(promises) { // 返回一个promise return new Promise((resolve, reject) =&gt; { // 遍历promises获取每个promise的结果 promises.forEach((p, index) =&gt; { Promise.resolve(p).then( value =&gt; { // 一旦有成功的，将return变为成功 resolve(value) }, reason =&gt; { // 只要一个失败了，return的promise就会失败 reject(reason) } ) }) }) } /** * 工具方法 --- resolveDelay(自定义方法) * 每返回一个promise对象，它在指定的时间后才确定结果 */ Promise.resolveDelay = function(value, time) { // 返回一个成功/失败的promise return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // value是promise if (value instanceof(Promise)) { // 使用value的结果作为promise的结果 value.then(resolve, reject) } else { // value不是promise =&gt; promise变为成功，数据是value resolve(value) } }, time); }) } /** * 工具方法 --- rejectDelay(自定义方法) * 每返回一个promise对象，它在指定的时间后才失败 */ Promise.rejectDelay = function(reason, time) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(reason) }, time); }) } // 向外暴露Promise函数 window.Promise = Promise})(window) 二、ES6 class版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266/** * 自定义Promise函数模块: class * */(function(window) { // 将经常使用的字符串用常量代替 const PENDING = 'pending' const RESOLVED = 'resolved' const REJECTED = 'rejected' class Promise { /** * Promise构造函数 * excutor: 执行器函数(同步执行) */ constructor(excutor) { // 将当前Promise保存起来 const me = this me.status = PENDING // 给promise对象指定status属性，初始值为pending me.data = undefined // 给promise对象指定一个用于存储结果数据的属性 me.callbacks = [] // 每个元素的结构: {onResolved() {}, onRejected() {}} function resolve(value) { // 如果当前状态不是pending，直接结束 --- 因为pending只能改一次 if (me.status !== PENDING) { return } // 将状态改为resolved me.status = RESOLVED // 保存value me.data = value // 如果存在待执行的callback函数，立即异步执行回调函数onResolved if (me.callbacks.length &gt; 0) { // 模拟异步，执行放入队列中所有成功的回调函数 setTimeout(() =&gt; { me.callbacks.forEach(callbacksObj =&gt; { callbacksObj.onResolved(value) }); }) } } function reject(reason) { // 如果当前状态不是pending，直接结束 --- 因为pending只能改一次 if (me.status !== PENDING) { return } // 将状态改为rejected me.status = REJECTED // 保存value me.data = reason // 如果存在待执行的callback函数，立即异步执行回调函数onRejected if (me.callbacks.length &gt; 0) { // 模拟异步，执行放入队列中所有成功的回调函数 setTimeout(() =&gt; { me.callbacks.forEach(callbacksObj =&gt; { callbacksObj.onRejected(reason) }); }) } } // 立即同步执行excutor // 如果调用失败，则需捕获异常 try { excutor(resolve, reject) } catch (error) { // 如果执行器抛出异常，promise对象变为rejected状态 reject(error) } } /** * Promise原形对象的then() * 指定成功和失败的回调函数 * 返回一个新的Promise对象 */ then(onResolved, onRejected) { onResolved = typeof onResolved === 'function' ? onResolved : value =&gt; value // 向后传递成功的value // 指定默认的失败的回调(实现错误/异常传透的关键点) onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; { throw reason } // 向后传递失败的reason const me = this // 返回一个新的Promise对象 return new Promise((resolve, reject) =&gt; { /** * 调用指定的回调函数处理，根据执行结果，改变return的promise状态 */ function handle(callback) { /** * 1.如果抛出异常，return的promise就会失败，reason就是error * 2.如果回调函数返回不是promise，return的promise就会成功，value就是返回值 * 3.如果回调函数返回是promise，return的promise结果就是这个promise的结果 */ try { const result = callback(me.data) // 3.如果回调函数返回是promise，return的promise结果就是这个promise的结果 if (result.instanceof(Promise)) { // result.then((resolve, reject) =&gt; { // value =&gt; resolve(value), // reason =&gt; reject(reason), // }) // 简化 result.then(resolve, reject) } else { // 2.如果回调函数返回不是promise，return的promise就会成功，value就是返回值 resolve(result) } } catch (error) { // 1.如果抛出异常，return的promise就会失败，reason就是error reject(error) } } // 当前还是pending状态，将回调函数保存起来 if (me.status === PENDING) { me.callbacks.push({ onResolved(value) { handle(onResolved) }, onRejected(reason) { handle(onRejected) } }) } else if (me.status === RESOLVED) { // 如果当前是resolved状态，异步执行onResolve并改变return的Promise状态 // 回调函数需异步执行 setTimeout(() =&gt; { handle(onResolved) }) } else { // 果当前是rejected状态，异步执行onRejected并改变return的Promise状态 // 回调函数需异步执行 setTimeout(() =&gt; { handle(onRejected) }) } }) } /** * Promise原形对象的catch() * 指定失败的回调函数 * 返回一个新的Promise对象 */ catch (onRejected) { return this.then(undefined, onRejected) } /** * Promise函数对象的resolve方法 * 返回一个指定结果的成功的Promise * * 注: 给类对象添加方法 * 在函数前加上 static */ static resolve = function(value) { // 返回一个成功/失败的promise return new Promise((resolve, reject) =&gt; { // value是promise时 if (value instanceof(Promise)) { // 使用value的结果作为promise的结果 value.then(resolve, reject) } else { // value不是promise时，promise成功，数据是value resolve(value) } }) } /** * Promise函数对象的reject方法 * 返回一个指定reason的失败的Promise */ static reject = function(reason) { return new Promise((resolve, reject) =&gt; { reject(reason) }) } /** * Promise函数对象的all方法 * 返回一个promise，只有当所有的promise都成功时才成功，否则只要有一个失败的就失败 */ static all = function(promises) { // 用来保存所有成功value的数组 const values = new Array(promises.length) // 用来保存成功的promise的数量 let resolvedCount = 0 // 返回一个新的promise return new Promise((resolve, reject) =&gt; { // 遍历promises获取每个promise的结果 promises.forEach((p, index) =&gt; { Promise.resolve(p).then( value =&gt; { resolvedCount++ // 成功的数量加1 // p成功，将成功的value保存到values // value.push(p) // 不行,成功的promise的顺序也必须是一一对应的 values[index] = value // 如果全部成功了，将return的promise改为成功 if (resolvedCount === promises.length) { resolve(values) } }, reason =&gt; { // 只要一个失败了，return的promise就会失败 reject(reason) } ) }) }) } /** * Promise函数对象的race方法 * 返回一个promise，其结果由第一个完成的promise决定 */ static race = function(promises) { // 返回一个promise return new Promise((resolve, reject) =&gt; { // 遍历promises获取每个promise的结果 promises.forEach((p, index) =&gt; { Promise.resolve(p).then( value =&gt; { // 一旦有成功的，将return变为成功 resolve(value) }, reason =&gt; { // 只要一个失败了，return的promise就会失败 reject(reason) } ) }) }) } /** * 工具方法 --- resolveDelay(自定义方法) * 每返回一个promise对象，它在指定的时间后才确定结果 */ static resolveDelay = function(value, time) { // 返回一个成功/失败的promise return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // value是promise if (value instanceof(Promise)) { // 使用value的结果作为promise的结果 value.then(resolve, reject) } else { // value不是promise =&gt; promise变为成功，数据是value resolve(value) } }, time); }) } /** * 工具方法 --- rejectDelay(自定义方法) * 每返回一个promise对象，它在指定的时间后才失败 */ static rejectDelay = function(reason, time) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(reason) }, time); }) } } // 向外暴露Promise函数 window.Promise = Promise})(window)","link":"/godread.github.io/32a89cf3.html"}],"tags":[{"name":"canvas","slug":"canvas","link":"/godread.github.io/tags/canvas/"},{"name":"cases","slug":"cases","link":"/godread.github.io/tags/cases/"},{"name":"sublime text3","slug":"sublime-text3","link":"/godread.github.io/tags/sublime-text3/"},{"name":"less","slug":"less","link":"/godread.github.io/tags/less/"},{"name":"h5","slug":"h5","link":"/godread.github.io/tags/h5/"},{"name":"zepto.js","slug":"zepto-js","link":"/godread.github.io/tags/zepto-js/"},{"name":"bootstrap","slug":"bootstrap","link":"/godread.github.io/tags/bootstrap/"},{"name":"跨域","slug":"跨域","link":"/godread.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"异步","slug":"异步","link":"/godread.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"ES6","slug":"ES6","link":"/godread.github.io/tags/ES6/"}],"categories":[{"name":"html5&amp;css3","slug":"html5-css3","link":"/godread.github.io/categories/html5-css3/"},{"name":"工具","slug":"工具","link":"/godread.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"javascript","slug":"javascript","link":"/godread.github.io/categories/javascript/"}]}